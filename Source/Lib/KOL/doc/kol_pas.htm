<html>

<head>
<title>KOL Help: unit KOL.pas</title>
</head>

<body bgcolor="#FFFFEF" text="#000000" link="#008080" vlink="#008000" alink="#808000">

<h1 align="center">
<font face="Arial" color="#FF8080">unit KOL.pas</font>
</h1>
<hr>
<p>
Please note, that KOL does not use keyword 'class'. Instead,
poor Pascal 'object' is the base of our objects. So, remember,
how we worked earlier with such Object Pascal's objects:
<br>
- to create objects dynamically, use P&lt;objname&gt; instead of
T&lt;objname&gt; to allocate a pointer for dynamically created
object instance;
<br>
- remember, that constructors of objects can not be virtual.
Override procedure Init instead in your own derived objects;
<br>
- rather then call constructors of objects, call global procedures
New&lt;objname&gt; (e.g. <a href=#newlabel>NewLabel</a>). If not, first (for virtualally
created objects) call New( ); then call constructor Create
(which calls Init) - but this is possible only if the constructor
is overriden by a new one.
<br>
- the operator 'is' is not applicable to objects. And operator 'as'
is not necessary (and is not applicable too), use typecast to desired
object type, e.g.: &quot;PSomeObjectType( C )&quot; inplace of &quot;C as TSomeClassType&quot;.
<br>
<hr>
Also remember, that IF [ MyObj: PMyObj ] THEN
NOT[ with MyObj do ] BUT[ with MyObj^ do ]
Though it is possible to skip '^' symbol when accessing member
fields, methods, properties, e.g. [ MyObj.Execute; ]
<hr>
     <table border=1 cellpadding=6 width=100%>
     <colgroup valign=top span=2>
       <tr>
         <td>  objects  </td>     <td>   functions by category </td>
       </tr>
         <td>
<a href="_TObj.htm">_TObj</a>

<a href="TObj.htm">TObj</a><br>

<a href="TList.htm">TList</a>

<a href="TListEx.htm">TListEx</a>

<a href="TStrList.htm">TStrList</a>

<a href="TStrListEx.htm">TStrListEx</a><br>

<a href="TTree.htm">TTree</a>

<a href="TDirList.htm">TDirList</a>

<a href="TIniFile.htm">TIniFile</a>

<a href="TCabFile.htm">TCabFile</a>

<a href="TStream.htm">TStream</a><br>

<a href="TControl.htm">TControl</a><br>

<a href="TGraphicTool.htm">TGraphicTool</a>

<a href="TCanvas.htm">TCanvas</a>

<a href="TImageList.htm">TImageList</a>

<a href="TIcon.htm">TIcon</a>

<a href="TBitmap.htm">TBitmap</a>

<a href="TGif.htm">TGif</a>

<a href="TGifDecoder.htm">TGifDecoder</a>

<a href="TJpeg.htm">TJpeg</a><br>

<a href="TTimer.htm">TTimer</a>

<a href="TThread.htm">TThread</a>

<a href="TTrayIcon.htm">TTrayIcon</a>

<a href="TDirChange.htm">TDirChange</a>

<a href="TMediaPlayer.htm">TMediaPlayer</a><br>

<a href="TMenu.htm">TMenu</a>

<a href="TOpenSaveDialog.htm">TOpenSaveDialog</a>

<a href="TOpenDirDialog.htm">TOpenDirDialog</a>

<a href="TColorDialog.htm">TColorDialog</a><br>

<a href="TAction.htm">TAction</a>

<a href="TActionList.htm">TActionList</a><br>

<a href="Exception.htm">Exception</a><br>

         </td>
         <td>
<a href="kol_pas.htm#visual_objects_constructors">
Visual objects constructing functions
</a><br><br>
&nbsp;&nbsp;&nbsp;<a href="#Working with null-terminated and ansi strings">Working with null-terminated and ansi strings</a><br>

&nbsp;&nbsp;&nbsp;<a href="#Small bit arrays (max 32 bits in array)">Small bit arrays (max 32 bits in array)</a><br>

&nbsp;&nbsp;&nbsp;<a href="#Arithmetics, geometry and other utility functions">Arithmetics, geometry and other utility functions</a><br>

&nbsp;&nbsp;&nbsp;<a href="#Data sorting (quicksort implementation)">Data sorting (quicksort implementation)</a><br>

&nbsp;&nbsp;&nbsp;<a href="#String to number and number to string conversions">String to number and number to string conversions</a><br>

&nbsp;&nbsp;&nbsp;<a href="#64-bit integer numbers">64-bit integer numbers</a><br>

&nbsp;&nbsp;&nbsp;<a href="#Floating point numbers">Floating point numbers</a><br>

&nbsp;&nbsp;&nbsp;<a href="#Date and time handling">Date and time handling</a><br>

&nbsp;&nbsp;&nbsp;<a href="#File and directory routines">File and directory routines</a><br>

&nbsp;&nbsp;&nbsp;<a href="#System functions and working with windows">System functions and working with windows</a><br>

&nbsp;&nbsp;&nbsp;<a href="#Text in clipboard operations">Text in clipboard operations</a><br>

&nbsp;&nbsp;&nbsp;<a href="#Wrappers to registry API functions">Wrappers to registry API functions</a><br>

         </td>
     </table>
Following conditional symbols can be used in a project
(Project &brvbar; Options &brvbar; Directories/Conditional Defines)
to change code generated a bit. There are following:
<pre>
EXTERNAL_KOLDEFS      - since there are a lot of such symbols, it may be not
possible to include all the desired optional symbols
in the Project Options (Delphi has a restriction to 256
characters in a semicolon-separated list of included
options). This symbol allows to exceed this restriction:
you place your defines in an included file
EXTERNAL_DEFINES.INC, located in your project directory.
Since this is a normal pascal source, use usual Pascal
syntax:  add a directive (*$DEFINE symbol*) for each
symbol you want, and you can decorate it with usual
comments if necessary.
ENABLE_DEPRECATED     - some old declaration made &quot;deprecated&quot; and moved to
KOL_deprecated.inc. This symbol provides including
such declarations into KOL.pas and makes it available
again.
DISABLE_DEPRECATED    - (default) - disables deprecated declaration.
WIN                   - (default) - version for Windows.
LINUX                 - version for Linux (only PAS_VERSION) -- not yet ready
When not defined, symbol WIN is defined automatically.
LINUX_USE_HOME_STARTFDIR - in Linux app, HOME directory of the user will be
returned by <a href=#getstartdir>GetStartDir</a> function.
GTK                   - version for GTK (Linux or Win32) -- not yet ready
XQT                   - version for QT (Linux or Win32) -- not yet ready
FPC                   - Free Pascal version. KOL can be used with such compiler
to create Win32 applications. To create Win-CE
applications (with FPC compiler)), use the separate
version of KOL specially designed for it.
INPACKAGE             - version for Mirror Classes Library package (design-time
only). This option should be included only in MCK package
options and never in options of the KOL/MCK application.
PAS_VERSION           - to use Pascal version of the code.
PARANOIA              - to force short versions of asm instructions (for D5
and below, D6 and higher use those instructions always).
USE_CMOV              - force using CMOV machine instruction in asm code (not
recommended, still on some machines your application
will not work).
SMALLEST_CODE         - to create minimal code application (affected:
(o) SimpleGetCtlBrushHandle - returns solid silver brush
always;
(o) _NewWindowed
- only default system font used by default;
font of the parent control is not applied to its
children automatically (but see SMALLEST_CODE_PARENTFONT);
- fBrush always set to NIL by default (parent Brush
is not applied);
(o) WndProcDoEraseBkgnd
- child controls windows are not created in WM_ERASEBKGND
if were not created earlier (in most case, all OK
with this - controls are created BTW);
- SetBkColor, SetBkMode, SetBrushOrgEx are not
called (all OK therefore)
(o) by default, NOT_UNLOAD_RICHEDITLIB is defined if
UNLOAD_RICHEDITLIB is not defined in project options
(this minimizes finalization section).
(o) _NewControl
- BoundsRect initialized with a rectangle
(aParent.fMarginLeft, aParent.fMarginTop,
aParent.fMarginLeft+64, aParent.fMargin+64)
rather then with (aParent.fMargin+aParent.fMarginLeft,
aParent.fMargin+aParent.fMarginTop,
aParent.fMargin+aParent.fMarginLeft+64,
aParent.fMargin+aParent.fMarginTop+64).
In most cases this is enough.
(o) <a href=#int2hex>Int2Hex</a>
there are no check for second perameter &gt; 15
(o) .... other see in code
SMALLER_CODE          - like smallest code, but fuctionality is the same.
The speed can be lower therefore.
SMALLEST_CODE_PARENTFONT - Parent font therefore is applied for child controls,
but initially only.
NOT_USE_KOLMATH       - Only for _X_ (GTK + Linux): to prevent referencing
KOLmath in uses. This makes method <a href=tcanvas.htm#arc>TCanvas.Arc</a>
unavailable, but the application become smaller.
NOT_USE_EXCEPTIONS    - to prevent referencing unit ERR.PAS in uses even when
KOLmath is listed there.
REDEFINE_ABS          - usual <a href=#abs>Abs</a> works as a macro which is better in most
cases. But who knows...
CUSTOM_APPICON        - when this option is defined, the resource name for the
application icon is extracted from a file
CusomAppIconRsrcName_PAS.inc (place it in your project
folder and type there name of the recource in qutations).
By default, string 'MAIN' is used like in usual Delphi
application.
USE_NAMES             - to use property Name with any <a href=#tobj>TObj</a>. This makes also
available method <a href=tobj.htm#findobj>TObj.FindObj</a>( name ): <a href=#pobj>PObj</a>.
UNIQUE_NAMES          - provide Name property to be unique among all siblings.
USE_MHTOOLTIP         - to use KOLMHTOOLTIP.pas (actually it is not a separate
unit but a set of portions of code included into KOL.pas
in different places). This unit provides tooltips (hints)
for arbitrary controls which appear when mouse is over
such controls.
USE_GRUSH             - to use ToGRush.pas unit, which provides automatic
redirection of the most cintrols creation functions
to the KOLGRushControls.pas.
(USE_CONSTRUCTORS     - to use constructors like in VCL. Note: this option is
not carefully tested!)
TLIST_FAST            - very fast implementation of <a href=#tlist>TList</a> (for coast of some
additional code).
DFLT_TLIST_NOUSE_BLOCKS - for TLIST_FAST: by default, do not make all <a href=#tlist>TList</a>
objects using new (fast) algoritms, but only those of
<a href=#tlist>TList</a> objects, which property UseBlocks was set to
TRUE after creating it.
STREAM_LARGE64        - turns on support of streams (and files) of size larger
then 4 Gbytes. Data type Int64 used for parameters of
the most of methods and functions in such case. (Note:
Int64 was introduced since Delphi5, so in earlier Delphi
versions using this symbol is not possible).
STREAM_COMPAT         - still STREAM_LARGE64 appeared (in v2.84), most of
methods and functions declarations became incompatible
with earlier created extensions. This symbol provides
compatibility for such extensions, but it desables
using large streams.
OLD_STREAM_CAPACITY   - to use elder TStream.SetCapacity algorithm (it did not
make Capacity smaller than already achieved, but in
newer version, Capacity can be set to a smaller value,
and for memory streams, rest of memory is freeing in
such case).
OLD_MEMSTREAMS_SETSIZE - to use elder TStream.SetSize for memory streams. In
a new version, setting new size also changes Capacity
to the same value (in earlier case, a value for
Capacity property was calculated to become a bit
greater then a value set for Size property).
OLD_COMPAT            - to use symbol ';' as a file list separator (all operations
using <a href=#dofileop>DoFileOp</a> function such as <a href=#deletefile2recycle>DeleteFile2Recycle</a> and
<a href=#copymovefiles>CopyMoveFiles</a>).
OLD_REGKEYGETSUBKEYS  - to use elder version of <a href=#regkeygetsubkeys>RegKeyGetSubKeys</a> functions
(new version is faster).
OLD_REGKEYGETVALUENAMES - to use elder version of <a href=#regkeygetvaluenames>RegKeyGetValueNames</a>
(newer version is faster).
USE_CUSTOMEXTENSIONS  - to extend <a href=#tcontrol>TControl</a> with custom additions.
UNICODE_CTRLS         - to use Unicode versions of controls (WM_XXXXW messages,
etc.)
SAFE_CODE             - use more safe code in some algorithms (but more slowly
and taking more code a bit).
USE_OnIdle            - to use OnIdle event
SNAPMOUSE2DFLTBTN     - for all MessageBox-based functions, snap mouse to
default button is provided if such option is on in
mouse driver settings.
BUTTON_DBLCLICK       - to prevent clicking buttons with double click (separate
event OnMouseDblClk is fired in such case), this takes
smaller code but buttons can not be pressed with mouse
fast. When SMALLEST_CODE on, this option also is on.
ALL_BUTTONS_RESPOND_TO_ENTER - obvious (by default, buttons respond to key
SPACE, since those are working this way in Windows).
CLICK_DEFAULT_CANCEL_BTN_DIRECTLY - to prevent visual effect of default/cancel
button pressing with Enter/Escape keys. Also, button
don't become focused in such case.
DEFAULT_CANCEL_BTN_EXCLUSIVE - to disable assigning to a button properties
DefaultBtn and CancelBtn simultaneously.
NO_DEFAULT_BUTTON_BOLD - to prevent DefaultBtn to be visually with
a bold border.
BITBTN_DISABLEDGLYPH2 - to restore old behaviour of multi-glyph bitbtn, when
index 2 was used to represent the button in disabled
state, and glyph with index 1 was used forpressed dtate.
<a href=#now>Now</a> by default index 1 corresponds to the disabled state,
and index 2 to the pressed state, i.e. these are swapped.
ESC_CLOSE_DIALOGS     - to allow closing all dialogs with ESCAPE.
KEY_PREVIEW           - form also receive WM_KEYDOWN (OnKeyDown event fired)
SUPPORT_ONDEADCHAR    - to support OnKeyDeadChar event in responce to
WM_DEADCHAR, WM_SYSDEADCHAR
OpenSaveDialog_Extended - to allow using custom extensions for OpenSaveDialog.
AUTO_CONTEXT_HELP     - to use automatic respond to WM_CONTEXTMENU to call
context help.
NOT_FIX_CURINDEX      - to use old version of <a href=tcontrol.htm#setitems>TControl.SetItems</a>, which could
lead to loose CurIndex value (e.g. for Combobox)
NOT_FIX_MODAL         - not to fix modal (if fixed, click on any window
activates the application. If not fixed, code is
smaller very a little, but only click on modal form
activates the application). This does not fix calling
<a href=#msgbox>MsgBox</a> though.
MODAL_ACTIVATE_FIX    - if this option is set, all the windows of clicked app
with active modal form are brought to foreground, not
only modal form itself. This option is not necessary if
only two forms are visible at a time (the main form and
the active modal form).
NEW_MODAL             - to use extended modalness.
USE_SETMODALRESULT    - to guarantee ModalResult property assigning handling.
USE_SHOWMODALPARENTED_ALWAYS - to use <a href=tcontrol.htm#showmodalparented>TControl.ShowModalParented</a>( <a href=#applet>Applet</a> )
instead of <a href=tcontrol.htm#showmodal>TControl.ShowModal</a> always.
USE_MENU_CURCTL       - to use CurCtl property in popup menu to detect which
control initiated a pop-up.
NEW_MENU_ACCELL       - to use new menu accelerators handling, without
AcceleratorTable (not tested for all cases)
USE_DROPDOWNCOUNT     - to force setting combobox dropdown count.
NOT_UNLOAD_RICHEDITLIB - to stop unload Rich Edit library in finalization
section (to economy several byte of code).
NOT_USE_RICHEDIT      - not use richedit (it will not be possible to create richedit)
TV_DRAG_RBUTTON       - to allow dragging tree view items with right mouse
button too.
TOOLBAR_FORCE_CHILDALIGN - this option provides Align working for child
controls of the toolbar control, but when with this option
is turned on it is impossible to have neighbour controls
on a form correctly aligned. This last disadvantage is
not important if a toolbar is always placed on a separate
panel-like control as a child.
Note: this option has no effect for Win9x, still use of
it under Win9x can crash the application!!!
TOOLBAR_DOT_NOAUTOSIZE_BUTTON - this option forces prefix dot character in
button caption to be treated as an instruction to
remove TBSTYLE_AUTOSIZE from the button style. Actually,
this feature not necessary still custom button size can
be set even if such style is on for a button.
CANRESIZE_THICKFRAME  - to use elder version of CanResize, changing border
style of the window (this cause incorrect form view in
Vista Aero theme (due a bug in Vista?)).
ANCHORS_WM_SIZE       - to check WM_SIZE message in Anchor handling window
procedure. By default, now used WM_WINDOWPOSCHANGED.
USE_PROP              - to use GetProp / SetProp (old style) in place of
Get / SetWindowLong( wnd, GWL_USERDATA... ) (slower?)
PROVIDE_EXITCODE      - PostQuitMessage( value ) assigns value to ExitCode
INITIALFORMSIZE_FIXMENU - form size initially is really the same as defined at
design time even for forms having main menu bar
USE_GRAPHCTLS         - to use graphic (non-windowed) controls
RICHEDIT_XPBORDER     - provide correct drawing rich edit control border with
XP themes.
GRAPHCTL_XPSTYLES     - to use XP themed Visual styles for drawing graphic
controls. This does not affect windowed controls
which visual style is controlled by the manifest.
This option also turns on RICHEDIT_XPBORDER option.
GRAPHCTL_HOTTRACK     - to use hot-tracking also together with XP themed
graphic controls (otherwise only static XP themed
view is provided). Also, turn this option on if you
want to handle OnMouseEnter and OnMouseLeabe events
for graphic controls.
NEW_OPEN_DIR_STYLE_EX - to use new code for <a href=#topendirdialog>TOpenDirDialog</a>, which provides
correct working of the dialog with an option
odNewDialogStyle set (even in Windows 9x system).
HTMLHELP_NOTOP        - when Html help is called, its window become a child of
the desktop, not application (in such case it is not
closed together with the application, and it is apper
not on top of the application).
ICON_DIFF_WH          - to support icons having Width &lt;&gt; Height
ICONLOAD_PRESERVEBMPS - when an icon is loaded, its bitmap and mask are
extracted and in case when such symbol is defined,
these one or two bitmaps are preserved until <a href=#ticon>TIcon</a>
object is destroyed.
LOADEX                - to use <a href=tbitmap.htm#loadfromstreamex>TBitmap.LoadFromStreamEx</a> while loading icon
from a stream or a file.
USE_OLDCONVERT2MASK   - to use elder Convert2Mask method (newer is more correct).
FIX_TRANSPBMPPALETTE  - for <a href=tbitmap.htm#stretchdrawmasked>TBitmap.StretchDrawMasked</a>, bitmaps with PixelFormat
= pf4bit or pf8bit are first converted (in a temporary
<a href=#tbitmap>TBitmap</a> object) to pf32bit, and then are drawn. This
fixes problems with palette usage for such DIB bitmaps.
FILL_BROKEN_BITMAP    - <a href=tbitmap.htm#loadfromstreamex>TBitmap.LoadFromStreamEx</a>: broken bitmaps rest of
scanlines are be filled with zeroes (usually black color)
rather then left containing trash memory bits.
AUTO_REPLACE_CLEARTYPE- to replace automatically CLEARTYPE_QUALITY fonts
with ANTIALIASED_QUALITY when running under elder
Windows version than XP.
FORCE_ALTERNATEFILENAME- <a href=tdirlist.htm#scandirectoryforce_alternatefilename>TDirList.ScanDirectoryFORCE_ALTERNATEFILENAME</a> - forced
using an alternate file path and filename for unicode
paths (принудительное использование альтернативного имени
пути и имени файла для юникод путей)
NEW_GRADIENT - to use new gradient painting by homm (fast).
OLD_ALIGN    - to prevent using new Align by Galkov.
NEW_ALIGN    - (default) - to use new Align implementation (faster).
OLD_TRANSPARENT       - to prevent using NEW_TRANSPARENT
NEW_TRANSPARENT       - created by Alexander Karpinsky a.k.a. homm (faster)
SBOX_OLDPOS           - to use elder formulas to calculate scroll box positions
(just for compatibility with very old apps using it).
OLD_REFCOUNT          - to prevent using new RefInc / RefDec behaviour
(new style of using RefCount works better).
OLD_FREE              - to declare Free as a method as in earlier versions of KOL.
In new versions, Free is declared as a property, and
&quot;calling&quot; it just redirects call to RefDec. OLD_FREE
can be used for compatibility with compilers not
understanding &quot;calling&quot; a property without assigning
something to or from it (Turbo Delphi?).
SCROLL_OLD            - for compatibility with the old applications using
TScrollBar: there was another method of adjusting
SBMax and SBPageSize: SBMax should be corrected to
(nMaxItems-1-SBPageSize).
FILE_EXISTS_EX - to use more correct (but a bit large code in <a href=#fileexists>FileExists</a> functon)
USE_AUTOFREE4CONTROLS - (default) - from 2.40, most of control sub-objects are
destroying using Add2AutoFree (smaller code).
NOT_USE_AUTOFREE4CONTROLS - this option returns to previous behaviour (just to
compare code size). Will be deprecated in future.
ENDSESSION_HALT - to halt the process when WM_ENDSESSION comes.
FILESTREAM_POSITION   - in PAS_VERSION, Stream..fData.fPosition always show
current position (for debug purposes)
PSEUDO_THREADS        - to use pseudo-threads instead of normal threads.
WAIT_SLEEP            - for PSEUDO_THREADS: sleep 10 ms in a
WaitForMultipleObjects loop.
ENUM_DYN_HANDLERS_AFTER_RUN - to allow all the events handling even when
<a href=#appletterminated>AppletTerminated</a> become TRUE.
STOP_WNDPROCTRANSPARENT_AFTER_APPLETTERMINATED - use this long-named otpion to
prevent any functionality of WndProcTransparent after
<a href=#appletterminated>AppletTerminated</a> is set to true.
STOPTIMER_AFTER_APPLETTERMINATED - use this symbol to prevent timer event
firing after setting <a href=#appletterminated>AppletTerminated</a> to TRUE.
TIMER_APPLETWND       - to use <a href=#applet>Applet</a> window to handle WM_TIMER events
(otherwise special single invisible window is created
to handle such events).
SUPPORT_LONG_TIMER    - LINUX only: set this option if <a href=ttimer.htm#interval>TTimer.Interval</a> can be
set to a value greater then 1,800,000 (30 minutes).
DEBUG_MENU            - to debug menu.
DEBUG_GDIOBJECTS      - to allow counting all the GDI objects used.
CHK_BITBLT            - to check BitBlt operations.
DEBUG_ENDSESSION      - to allow debugging WM_ENDSESSION handling.
DEBUG_CREATEWINDOW    - to debug CreateWindow.
CRASH_DEBUG           - to fill object memory with $DD before freeing it
(program really crashes when the object is
attempted to destroy more then once and in most
cases when a destroyed object is accessed after the
destruction).
DEBUG_MCK             - specially designed to debug Mirror Classes Kit.
DEBUG                 - other debugging.
EXTERNAL_DEFINES      - if count of options necessary to set is very large
Delphi ignores past of those. To avoid this problem,
set only this option in Project's options, and place
all other options to ExternalDefines.inc file as a
sequence of {$DEFINE ... directives.
But note, such file should be located in a
project directory, but not in the directory where KOL.pas
is located. This is enough to provide different sets
of defines for each project.
</pre>
</p>
<h2 align="center"><font face="Arial" color="#FF8080">Content</font></h2>
<a name="pobj"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>PObj</b></font> = ^ <a href=#tobj>TObj</a>;</font>
<br>
</p>
<a name="plist"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>PList</b></font> = ^ <a href=#tlist>TList</a>;</font>
<br>
</p>
<a name="tobjectmethod"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TObjectMethod</b></font> = <b>procedure</b> <b>of</b> <b>object</b>;</font>
<br>
</p>
<a name="tonevent"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnEvent</b></font> = <b>procedure</b>( Sender: <a href=#pobj>PObj</a> ) <b>of</b> <b>object</b>;</font>
<br>
This type of event is the most common - event handler when called can
know only what object was a sender of this call. Replaces good known
VCL TNotifyEvent event type.
</p>
<a name="newlist"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewList</b></font>: <a href=#plist>PList</a>;</font>
<br>
Returns pointer to newly created <a href=#tlist>TList</a> object. Use it instead usual
<a href=tlist.htm#create>TList.Create</a> as it is done in VCL or XCL.
</p>
<a name="newlistinit"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewListInit</b></font>( <b>const</b> AItems: <b>array</b> <b>of</b> <b>Pointer</b> ): <a href=#plist>PList</a>;</font>
<br>
Creates a list filling it initially with certain Items.
</p>
<a name="fastincnum2elements"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>FastIncNum2Elements</b></font>( List: <a href=#tlist>TList</a>; FromIdx, Count, Value: <b>Integer</b> );</font>
<br>
Very fast adds Value to List elements from List[FromIdx] to List[FromIdx+Count-1].
Given elements must exist. Count must be &gt; 0.
</p>
<a name="free_and_nil"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>Free_And_Nil</b></font>( <b>var</b> Obj );</font>
<br>
Obj.Free and Obj := nil, where Obj *MUST* be <a href=#tobj>TObj</a> or its descendant
(<a href=#tcontrol>TControl</a>, TMenu, etc.) This procedure is not compatible with VCL's
FreeAndNil, which works with TObject, since this it has another name.
</p>
<a name="tonthreadexecute"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnThreadExecute</b></font> = <b>function</b>( Sender: PThread ): <b>Integer</b> <b>of</b> <b>object</b>;</font>
<br>
Event to be called when Execute method is called for TThread
</p>
<a name="newthread"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewThread</b></font>: PThread;</font>
<br>
Creates thread object (always suspended). After creating, set event
OnExecute and perform Resume operation.
</p>
<a name="newthreadex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewThreadEx</b></font>( <b>const</b> Proc: <a href=#tonthreadexecute>TOnThreadExecute</a> ): PThread; stdcall;</font>
<br>
Creates thread object, assigns Proc to its OnExecute event and runs
it.
</p>
<a name="newthreadautofree"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewThreadAutoFree</b></font>( <b>const</b> Proc: <a href=#tonthreadexecute>TOnThreadExecute</a> ): PThread;</font>
<br>
Creates thread object similar to <a href=#newthreadex>NewThreadEx</a>, but freeing automatically
when executing of such thread finished. Be sure that a thread is resumed
at least to provide its object keeper freeing.
</p>
<a name="_newstream"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>_NewStream</b></font>( <b>const</b> StreamMethods: TStreamMethods ): PStream;</font>
<br>
Use this method only to define your own stream type. See also declared
below (in KOL.pas) methods used to implement standard KOL streams. You can use it in
your code to create streams, which are partially based on standard
methods.
</p>
<a name="newfilestream"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewFileStream</b></font>( <b>const</b> FileName: KOLString; Options: <b>DWORD</b> ): PStream;</font>
<br>
Creates file stream for read and write. Exact set of open attributes
should be passed through Options parameter (see <a href=#filecreate>FileCreate</a> where those
flags are listed).
</p>
<a name="newfilestreamwithevent"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewFileStreamWithEvent</b></font>( <b>const</b> FileName: KOLString; Options: <b>DWORD</b> ): PStream;</font>
<br>
Creates file stream for read and write. Exact set of open attributes
should be passed through Options parameter (see <a href=#filecreate>FileCreate</a> where those
flags are listed). Also, resulting stream is supporting OnChangePos event.
</p>
<a name="newreadfilestream"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewReadFileStream</b></font>( <b>const</b> FileName: KOLString ): PStream;</font>
<br>
Creates file stream for read only.
</p>
<a name="newreadfilestreamwithevent"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewReadFileStreamWithEvent</b></font>( <b>const</b> FileName: KOLString ): PStream;</font>
<br>
Creates file stream for read only, supporting OnChangePos event.
</p>
<a name="newwritefilestream"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewWriteFileStream</b></font>( <b>const</b> FileName: KOLString ): PStream;</font>
<br>
Creates file stream for write only. Truncating of file (if needed)
is provided automatically.
</p>
<a name="newwritefilestreamwithevent"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewWriteFileStreamWithEvent</b></font>( <b>const</b> FileName: KOLString ): PStream;</font>
<br>
Creates file stream for write only. Truncating of file (if needed)
is provided automatically. Created stream supports OnChangePos event.
</p>
<a name="newreadwritefilestream"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewReadWriteFileStream</b></font>( <b>const</b> FileName: KOLString ): PStream;</font>
<br>
Creates stream for read and write file. To truncate file, if it is
necessary, change Size property.
</p>
<a name="newreadfilestreamw"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewReadFileStreamW</b></font>( <b>const</b> FileName: WideString ): PStream;</font>
<br>
Creates file stream for read only.
</p>
<a name="newwritefilestreamw"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewWriteFileStreamW</b></font>( <b>const</b> FileName: WideString ): PStream;</font>
<br>
Creates file stream for write only. Truncating of file (if needed)
is provided automatically.
</p>
<a name="newreadwritefilestreamw"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewReadWriteFileStreamW</b></font>( <b>const</b> FileName: WideString ): PStream;</font>
<br>
Creates stream for read and write file. To truncate file, if it is
necessary, change Size property.
</p>
<a name="newexfilestream"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewExFileStream</b></font>( F: HFile ): PStream;</font>
<br>
Creates read only stream to read from opened file or pipe from the current
position.
When stream is destroyed, file handle still not closed (your code should do
this) and file position is not changed (after the last read operation).
</p>
<a name="newmemorystream"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewMemoryStream</b></font>: PStream;</font>
<br>
Creates memory stream (read and write).
</p>
<a name="newmemorystreamwithevent"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewMemoryStreamWithEvent</b></font>: PStream;</font>
<br>
Creates memory stream (read and write). Created stream support OnChangePos
event.
</p>
<a name="newexmemorystream"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewExMemoryStream</b></font>( ExistingMem: <b>Pointer</b>; Size: <b>DWORD</b> ): PStream;</font>
<br>
Creates memory stream on base of existing memory. It is not possible
to write out of top bound given by Size (i.e. memory can not be resized,
or reallocated. When stream object is destroyed this memory is not freed.
</p>
<a name="newconcatstream"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewConcatStream</b></font>( Stream1, Stream2: PStream ): PStream;</font>
<br>
Creates a stream which is a concatenation of two source stream. After
the call, both source streams are belonging to the resulting stream and these
will be destroyed together with the resulting stream. (So forget about it).
After the call, first stream will not be changed in size via methods of
concatenated stream (and it is not recommended to use further Stream1 and
Stream2 methods too). But Stream2 can still be increased, if it allows doing
so when some data are appended or Size of resulting stream is changed (but
not less then Stream1.Size).
Nature and physical location of Stream1 and Stream2 are not important and
can be absolutely different. But it is supposed that both streams are not
compressed and its Size is known always and Seek operation is valid.
This function accepts recursive (multi-level) usage: resulting concatenation
stream can be used as a left or right parameter to create another concatenation
stream later, so it is possible to build a tree of streams concatenated,
concatenating this way several different streams and use it as a single
data streaming object.
</p>
<a name="newsubstream"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewSubStream</b></font>( BaseStream: PStream; <b>const</b> FromPos, Size: TStrmSize ): PStream;</font>
<br>
Creates a stream which is a subpart of BaseStream passes, starting from
FromPos and with given Size. Like in function <a href=#newconcatstream>NewConcatStream</a>, passes
BaseStream become owned by newly created sub-stream object, and will be
destroyed automatically together with a sub-stream.
If you want to provide more long life time for a base stream (e.g. if you
plan to use it after a sub-stream based on it is destroyed), use method
RefInc for base stream once to prevent it from destroying when the sub-stream
is destroyed.
Note: be careful and avoid direct calling methods and properties of the base
stream, while you have a sub-stream created on base it, since the sub-stream
actually redirects all the requests to the parent base stream.
Sub-stream accepts setting Size to greater value later, and if some data
are written to it, it is written actually to the base stream, and when it
is written beyond the end position, this will increase size of the base
stream too (and if it is a file stream, this also will increase size of the
file on which the base stream was created).
This function accepts recursive (multi-level) usage: it is possible to create
later another sub-stream on base of existing sub-stream, still it is actully
can be treated as usual stream.
</p>
<a name="stream2stream"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Stream2Stream</b></font>( Dst, Src: PStream; <b>const</b> Count: TStrmSize ): TStrmSize;</font>
<br>
Copies Count (or less, if the rest of Src is not sufficiently long)
bytes from Src to Dst, but with optimizing in cases, when Src or/and
Dst are memory streams (intermediate buffer is not allocated).
</p>
<a name="stream2streamex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Stream2StreamEx</b></font>( Dst, Src: PStream; <b>const</b> Count: TStrmSize ): TStrmSize;</font>
<br>
Copies Count bytes from Src to Dst, but without any optimization.
Unlike <a href=#stream2stream>Stream2Stream</a> function, it can be applied to very large streams.
See also <a href=#stream2streamexbufsz>Stream2StreamExBufSz</a>.
</p>
<a name="stream2streamexbufsz"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Stream2StreamExBufSz</b></font>( Dst, Src: PStream; <b>const</b> Count: TStrmSize; BufSz: <b>DWORD</b> ): TStrmSize;</font>
<br>
Copies Count bytes from Src to Dst using buffer of given size, but without
other optimizations.
Unlike <a href=#stream2stream>Stream2Stream</a> function, it can be applied to very large streams
</p>
<a name="resource2stream"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Resource2Stream</b></font>( DestStrm: PStream; Inst: HInst; ResName: PKOLChar; ResType: PKOLChar ): <b>Integer</b>;</font>
<br>
Loads given resource to DestStrm. Useful for non-standard
resources to load it into memory (use memory stream for such
purpose). Use one of following resource types to pass as ResType:
<pre>
RT_ACCELERATOR Accelerator table
RT_ANICURSOR Animated cursor
RT_ANIICON Animated icon
RT_BITMAP Bitmap resource
RT_CURSOR Hardware-dependent cursor resource
RT_DIALOG Dialog box
RT_FONT         Font resource
RT_FONTDIR Font directory resource
RT_GROUP_CURSOR Hardware-independent cursor resource
RT_GROUP_ICON Hardware-independent icon resource
RT_ICON         Hardware-dependent icon resource
RT_MENU         Menu resource
RT_MESSAGETABLE Message-table entry
RT_RCDATA Application-defined resource (raw data)
RT_STRING String-table entry
RT_VERSION Version resource
</pre>
<br>For example:
<p align=left><font face="Courier" color="008080"><b><pre>
<font color="800000"><b>var</b></font> MemStrm: PStream;
    JpgObj: PJpeg;
......
 MemStrm := <a href="kol_pas.htm#newmemorystream target="_top""><font color="008080">NewMemoryStream</font></a>;
 JpgObj := NewJpeg;
......
 Resource2Stream( MemStrm, hInstance, <font color="A08020">'MYJPEG'</font>, RT_RCDATA );
 MemStrm.Position := 0;
 JpgObj.LoadFromStream( MemStrm );
 MemStrm.Free;
......
</pre></b></font></p>
</p>
<a name="newstrlist"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewStrList</b></font>: PStrList;</font>
<br>
Creates string list object.
</p>
<a name="getfilelist"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetFileList</b></font>( <b>const</b> dir: Ansistring ): PStrList;</font>
<br>
By Alexander Shakhaylo. Returns list of file names of the given directory.
</p>
<a name="wstrlen"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WStrLen</b></font>( W: PWideChar ): <b>Integer</b>;</font>
<br>
Returns Length of null-terminated Unicode string.
</p>
<a name="newstrlistex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewStrListEx</b></font>: PStrListEx;</font>
<br>
Creates extended string list object.
</p>
<a name="wstrcopy"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>WStrCopy</b></font>( Dest, Src: PWideChar );</font>
<br>
Copies null-terminated Unicode string (terminated null also copied).
</p>
<a name="wstrlcopy"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>WStrLCopy</b></font>( Dest, Src: PWideChar; MaxLen: <b>Integer</b> );</font>
<br>
Copies null-terminated Unicode string (terminated null also copied).
</p>
<a name="wstrcmp"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WStrCmp</b></font>( W1, W2: PWideChar ): <b>Integer</b>;</font>
<br>
Compares two null-terminated Unicode strings.
</p>
<a name="wstrcmp_nocase"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WStrCmp_NoCase</b></font>( W1, W2: PWideChar ): <b>Integer</b>;</font>
<br>
Compares two null-terminated Unicode strings.
</p>
<a name="pwstrlist"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>PWStrList</b></font> = ^ TWstrList;</font>
<br>
</p>
<a name="newwstrlist"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewWStrList</b></font>: <a href=#pwstrlist>PWStrList</a>;</font>
<br>
Creates new <a href=#twstrlist>TWStrList</a> object and returns a pointer to it.
</p>
<a name="newwstrlistex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewWStrListEx</b></font>: PWStrListEx;</font>
<br>
Creates new <a href=#twstrlistex>TWStrListEx</a> objects and returns a pointer to it.
</p>
<a name="tgraphictooltype"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TGraphicToolType</b></font> =( gttBrush, gttFont, gttPen );</font>
<br>
Graphic object types, mainly for internal use.
</p>
<a name="pgraphictool"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>PGraphicTool</b></font> = ^ <a href=#tgraphictool>TGraphicTool</a>;</font>
<br>
</p>
<a name="tongraphicchange"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnGraphicChange</b></font> = <b>procedure</b>( Sender: <a href=#pgraphictool>PGraphicTool</a> ) <b>of</b> <b>object</b>;</font>
<br>
An event mainly for internal use.
</p>
<a name="tbrushstyle"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TBrushStyle</b></font> =( bsSolid, bsClear, bsHorizontal, bsVertical, bsFDiagonal, bsBDiagonal, bsCross, bsDiagCross );</font>
<br>
Available brush styles.
</p>
<a name="tfontstyles"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TFontStyles</b></font> =( fsBold, fsItalic, fsUnderline, fsStrikeOut );</font>
<br>
Available font styles.
</p>
<a name="tfontstyle"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TFontStyle</b></font> = <b>set</b> <b>of</b> <a href=#tfontstyles>TFontStyles</a>;</font>
<br>
Font style is representing as a set of XFontStyles.
</p>
<a name="tfontpitch"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TFontPitch</b></font> =( fpDefault, fpFixed, fpVariable );</font>
<br>
Availabe font pitch values.
</p>
<a name="tfontname"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TFontName</b></font> = <b>type</b> <b>string</b>;</font>
<br>
Font name is represented as a string.
</p>
<a name="tfontcharset"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TFontCharset</b></font> = 0 . . 255;</font>
<br>
Font charset is represented by number from 0 to 255.
</p>
<a name="tfontquality"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TFontQuality</b></font> =( fqDefault, fqDraft, fqProof, fqNonAntialiased, fqAntialiased, fqClearType );</font>
<br>
Font quality.
</p>
<a name="tpenstyle"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TPenStyle</b></font> =( psSolid, psDash, psDot, psDashDot, psDashDotDot, psClear, psInsideFrame );</font>
<br>
Available pen styles. For more info see Delphi or Win32 help files.
</p>
<a name="tpenmode"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TPenMode</b></font> =( pmBlack, pmNotMerge, pmMaskNotPen, pmNotCopy, pmMaskPenNot, pmNot, pmXor, pmNotMask, pmMask, pmNotXor, pmNop, pmMergePenNot, pmCopy, pmMergeNotPen, pmMerge, pmWhite );</font>
<br>
Available pen modes. For more info see Delphi or Win32 help files.
</p>
<a name="tpenendcap"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TPenEndCap</b></font> =( pecRound, pecSquare, pecFlat );</font>
<br>
Avalable (for geometric pen) end cap styles.
</p>
<a name="tpenjoin"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TPenJoin</b></font> =( pjRound, pjBevel, pjMiter );</font>
<br>
Available (for geometric pen) join styles.
</p>
<a name="color2rgb"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Color2RGB</b></font>( Color: TColor ): TColor;</font>
<br>
Function to get RGB color from system color. Parameter can be also RGB
color, in that case result is just equal to a parameter.
</p>
<a name="rgb2bgr"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RGB2BGR</b></font>( Color: TColor ): TColor;</font>
<br>
Converts RGB color to BGR
</p>
<a name="colorsmix"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ColorsMix</b></font>( Color1, Color2: TColor ): TColor;</font>
<br>
Returns color, which RGB components are build as an (approximate)
arithmetic mean of correspondent RGB components of both source
colors (these both are first converted from system to RGB, and
result is always RGB color). Please note: this function is fast,
but can be not too exact.
</p>
<a name="color2rgbquad"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Color2RGBQuad</b></font>( Color: TColor ): TRGBQuad;</font>
<br>
Converts color to RGB, used to represent RGB values in palette entries
(actually swaps R and B bytes).
</p>
<a name="color2color16"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Color2Color16</b></font>( Color: TColor ): <b>WORD</b>;</font>
<br>
Converts Color to RGB, packed to word (as it is used in format pf16bit).
</p>
<a name="color2color15"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Color2Color15</b></font>( Color: TColor ): <b>WORD</b>;</font>
<br>
Converts Color to RGB, packed to word (as it is used in format pf15bit).
</p>
<a name="deffontcolor"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>DefFontColor</b></font>: TColor = clWindowText;</font>
<br>
Default font color.
</p>
<a name="globalgraphics_usefontorient"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>GlobalGraphics_UseFontOrient</b></font>: <b>Boolean</b>;</font>
<br>
Global flag. If stays False (default), Orientation property of Font
objects is ignored. This flag is set to True automatically in
RotateFonts add-on.
</p>
<a name="newfont"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewFont</b></font>: <a href=#pgraphictool>PGraphicTool</a>;</font>
<br>
Creates and returns font graphic tool object.
</p>
<a name="newbrush"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewBrush</b></font>: <a href=#pgraphictool>PGraphicTool</a>;</font>
<br>
Creates and returns new brush object.
</p>
<a name="newpen"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewPen</b></font>: <a href=#pgraphictool>PGraphicTool</a>;</font>
<br>
Creates and returns new pen object.
</p>
<a name="tfillstyle"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TFillStyle</b></font> =( fsSurface, fsBorder );</font>
<br>
Available filling styles. For more info see Win32 or Delphi help files.
</p>
<a name="tfillmode"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TFillMode</b></font> =( fmAlternate, fmWinding );</font>
<br>
Available filling modes. For more info see Win32 or Delphi help files.
</p>
<a name="tcopymode"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TCopyMode</b></font> = <b>Integer</b>;</font>
<br>
Available copying modes are following:
  cmBlackness<br>
  cmDstInvert<br>
  cmMergeCopy<br>
  cmMergePaint<br>
  cmNotSrcCopy<br>
  cmNotSrcErase<br>
  cmPatCopy<br>
  cmPatInvert<br>
  cmPatPaint<br>
  cmSrcAnd<br>
  cmSrcCopy<br>
  cmSrcErase<br>
  cmSrcInvert<br>
  cmSrcPaint<br>
  cmWhiteness<br>&nbsp;&nbsp;&nbsp;
Also it is possible to use any other available ROP2 modes. For more info,
see Win32 help files.
</p>
<a name="pcanvas"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>PCanvas</b></font> = ^ <a href=#tcanvas>TCanvas</a>;</font>
<br>
</p>
<a name="tongethandle"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnGetHandle</b></font> = <b>function</b>( Canvas: <a href=#pcanvas>PCanvas</a> ): HDC <b>of</b> <b>object</b>;</font>
<br>
For internal use mainly.
</p>
<a name="tontextarea"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnTextArea</b></font> = <b>procedure</b>( Sender: <a href=#pcanvas>PCanvas</a>; <b>var</b> Size: TSize; <b>var</b> P0: TPoint );</font>
<br>
Event to calculate actual area, occupying by a text. It is used
to optionally extend calculating of TextArea taking into considaration
font Orientation property.
</p>
<a name="newcanvas"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewCanvas</b></font>( DC: HDC ): <a href=#pcanvas>PCanvas</a>;</font>
<br>
Use to construct Canvas on base of memory DC.
</p>
<a name="globalcanvas_ontextarea"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>GlobalCanvas_OnTextArea</b></font>: <a href=#tontextarea>TOnTextArea</a>;</font>
<br>
Global event to extend Canvas with possible add-ons, applied
when rotated fonts are used only (to take into consideration
Font.Orientation property in TextArea method).
</p>
<a name="timagelistcolors"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TImageListColors</b></font> =( ilcColor, ilcColor4, ilcColor8, ilcColor16, ilcColor24, ilcColor32, ilcColorDDB, ilcDefault );</font>
<br>
ImageList color schemes available.
</p>
<a name="tdrawingstyles"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TDrawingStyles</b></font> =( dsBlend25, dsBlend50, dsMask, dsTransparent );</font>
<br>
ImageList drawing styles available.
</p>
<a name="tdrawingstyle"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TDrawingStyle</b></font> = <b>Set</b> <b>of</b> <a href=#tdrawingstyles>TDrawingStyles</a>;</font>
<br>
Style of drawing is a combination of all available drawing styles.
</p>
<a name="timagetype"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TImageType</b></font> =( itBitmap, itIcon, itCursor );</font>
<br>
ImageList types available.
</p>
<a name="pimagelist"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>PImageList</b></font> = ^ <a href=#timagelist>TImageList</a>;</font>
<br>
</p>
<a name="tpixelformat"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TPixelFormat</b></font> =( pfDevice, pf1bit, pf4bit, pf8bit, pf15bit, pf16bit, pf24bit, pf32bit, pfCustom );</font>
<br>
Available pixel formats.
</p>
<a name="tbitmaphandletype"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TBitmapHandleType</b></font> =( bmDIB, bmDDB );</font>
<br>
Available bitmap handle types.
</p>
<a name="newbitmap"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewBitmap</b></font>( W, H: <b>Integer</b> ): PBitmap;</font>
<br>
Creates bitmap object of given size. If it is possible, do not change its
size (Width and Heigth) later - this can economy code a bit. See <a href=#tbitmap>TBitmap</a>.
</p>
<a name="newdibbitmap"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewDIBBitmap</b></font>( W, H: <b>Integer</b>; PixelFormat: <a href=#tpixelformat>TPixelFormat</a> ): PBitmap;</font>
<br>
Creates DIB bitmap object of given size and pixel format. If it is possible,
do not change its size (Width and Heigth) later - this can economy code a bit.
See <a href=#tbitmap>TBitmap</a>.
</p>
<a name="calcscanlinesize"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CalcScanLineSize</b></font>( Header: PBitmapInfoHeader ): <b>Integer</b>;</font>
<br>
May be will be useful.
</p>
<a name="loadmappedbitmap"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>LoadMappedBitmap</b></font>( hInst: THandle; BmpResID: <b>Integer</b>; <b>const</b> Map: <b>array</b> <b>of</b> TColor ): HBitmap;</font>
<br>
This function can be used to load bitmap and replace some it colors to
desired ones. This function especially useful when loaded by the such way
bitmap is used as toolbar bitmap - to replace some original colors to
system default colors. To use this function properly, the bitmap shoud
be prepared as 16-color bitmap, which uses only system colors. To do so,
create a new 16-color bitmap with needed dimensions in Borland Image Editor
and paste a bitmap image, copyed in another graphic tool, and then save it.
If this is not done, bitmap will not be loaded correctly!
</p>
<a name="loadmappedbitmapex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>LoadMappedBitmapEx</b></font>( MasterObj: <a href=#pobj>PObj</a>; hInst: THandle; BmpResName: PKOLChar; <b>const</b> Map: <b>array</b> <b>of</b> TColor ): HBitmap;</font>
<br>
by Alex Pravdin: like <a href=#loadmappedbitmap>LoadMappedBitmap</a>, but much powerful. It uses
<a href=#createmappedbitmapex>CreateMappedBitmapEx</a>, so it understands any bitmap color format, including
pf24bit. Also, LoadMappedBitmapEx provides auto-destroying loaded resource
when MasterObj is destroyed.
</p>
<a name="createmappedbitmap"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CreateMappedBitmap</b></font>( Instance: THandle; Bitmap: <b>Integer</b>; Flags: UINT; ColorMap: PColorMap; NumMaps: <b>Integer</b> ): HBitmap; stdcall;</font>
<br>
Creates mapped bitmap replacing colors correspondently to the
ColorMap (each pare of colors defines color replaced and a color
used for replace it in the bitmap). See also <a href=#createmappedbitmapex>CreateMappedBitmapEx</a>.
</p>
<a name="createmappedbitmapex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CreateMappedBitmapEx</b></font>( Instance: THandle; BmpRsrcName: PKOLChar; Flags: Cardinal; ColorMap: PColorMap; NumMaps: <b>Integer</b> ): HBitmap;</font>
<br>
By Alex Pravdin.
Creates mapped bitmap independently from bitmap color format (works
correctly with bitmaps having format deeper than 8bit per pixel).
</p>
<a name="saveicons2stream"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>SaveIcons2Stream</b></font>( <b>const</b> Icons: <b>array</b> <b>of</b> PIcon; Strm: PStream );</font>
<br>
Saves several icons (of different dimentions) to stream.
</p>
<a name="saveicons2streamex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>SaveIcons2StreamEx</b></font>( <b>const</b> BmpHandles: <b>array</b> <b>of</b> HBitmap; Strm: PStream ): <b>Boolean</b>;</font>
<br>
Saves icons creating it from pairs of bitmaps and their masks.
BmpHandles array must contain pairs of bitmap handles, each pair
of color bitmap and mask bitmap of the same size.
</p>
<a name="saveicons2file"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>SaveIcons2File</b></font>( <b>const</b> Icons: <b>array</b> <b>of</b> PIcon; <b>const</b> FileName: KOLString );</font>
<br>
Saves several icons (of different dimentions) to file. (Single file
with extension .ico can contain several different sized icon images
to use later one with the most appropriate size).
</p>
<a name="newicon"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewIcon</b></font>: PIcon;</font>
<br>
Creates new icon object, setting its Size to 32 by default. Created icon
is Empty.
</p>
<a name="getfileiconcount"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetFileIconCount</b></font>( <b>const</b> FileName: KOLString ): <b>Integer</b>;</font>
<br>
Returns number of icon resources stored in given (executable) file.
</p>
<a name="loadimgicon"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>LoadImgIcon</b></font>( RsrcName: PKOLChar; Size: <b>Integer</b> ): HIcon;</font>
<br>
Loads icon of specified size from the resource.
</p>
<a name="id_self"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ID_SELF</b></font>: array[ 0 . . 5 ] <b>of</b> KOLChar =( 'S', 'E', 'L', 'F', '_', #0 );</font>
<br>
Identifier for window property &quot;Self&quot;, stored directly in window, when
it is created. This property is used to [fast] find <a href=#tcontrol>TControl</a> object,
correspondent to given window handle (using API call GetProp).
</p>
<a name="id_prevproc"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ID_PREVPROC</b></font>: array[ 0 . . 9 ] <b>of</b> KOLChar =( 'P', 'R', 'E', 'V', '_', 'P', 'R', 'O', 'C', #0 );</font>
<br>
</p>
<a name="pcontrol"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>PControl</b></font> = ^ <a href=#tcontrol>TControl</a>;</font>
<br>
Type of pointer to <a href=#tcontrol>TControl</a> visual object. All
<a href="kol_pas.htm#visual_objects_constructors">
constructing functions
</a>
New[ControlName] are returning
pointer of this type. Do not forget about some difference
of using objects from using classes. Identifier Self for
methods of object is not of pointer type, and to pass
pointer to Self, it is necessary to pass @Self instead.
At the same time, to use pointer to object in 'WITH' operator,
it is necessary to apply suffix '^' to pointer to get know
to compiler, what do You want.
</p>
<a name="twindowfunc"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TWindowFunc</b></font> = <b>function</b>( Sender: <a href=#pcontrol>PControl</a>; <b>var</b> Msg: TMsg; <b>var</b> Rslt: <b>Integer</b> ): <b>Boolean</b>;</font>
<br>
Event type to define custom extended message handlers (as pointers to
procedure entry points). Such handlers are usually defined like add-ons,
extending behaviour of certain controls and attached using AttachProc
method of <a href=#tcontrol>TControl</a>. If the handler detects, that it is necessary to stop
further message processing, it should return True.
</p>
<a name="tmousebutton"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TMouseButton</b></font> =( mbNone, mbLeft, mbRight, mbMiddle );</font>
<br>
Available mouse buttons. mbNone is useful to get know, that
there were no mouse buttons pressed.
</p>
<a name="tmouseeventdata"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TMouseEventData</b></font> = <b>packed</b> <b>Record</b></font>
<br>
Record to pass it to mouse handling routines, assigned to OnMouseXXXX
events.
<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">Button: <a href=#tmousebutton>TMouseButton</a>;</font>
    </td>
    <td valign="top">
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">StopHandling: <b>Boolean</b>;</font>
    </td>
    <td valign="top">
Set it to True in OnMouseXXXX event handler to
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">R1, R2: <b>Byte</b>;</font>
    </td>
    <td valign="top">
Not used
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">Shift : <b>DWORD</b>;</font>
    </td>
    <td valign="top">
HiWord( Shift ) = zDelta in WM_MOUSEWHEEL
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">X, Y  : SmallInt;</font>
    </td>
    <td valign="top">
    </td>
  </tr>
</table>
<font face="Courier" color="#800080"><b>end</b>;</font>
</p>
<a name="tonmouse"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnMouse</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; <b>var</b> Mouse: <a href=#tmouseeventdata>TMouseEventData</a> ) <b>of</b> <b>object</b>;</font>
<br>
Common mouse handling event type.
</p>
<a name="tonkey"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnKey</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; <b>var</b> Key: Longint; Shift: <b>DWORD</b> ) <b>of</b> <b>object</b>;</font>
<br>
Key events. Shift is a combination of flags MK_SHIFT, MK_CONTROL, MK_ALT.
(See <a href=#getshiftstate>GetShiftState</a> funtion).
</p>
<a name="tonchar"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnChar</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; <b>var</b> Key: KOLChar; Shift: <b>DWORD</b> ) <b>of</b> <b>object</b>;</font>
<br>
Char event. Shift is a combination of flags MK_SHIFT, MK_CONTROL, MK_ALT.
</p>
<a name="ttabkey"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TTabKey</b></font> =( tkTab, tkLeftRight, tkUpDown, tkPageUpPageDn );</font>
<br>
Available tabulating key groups.
</p>
<a name="ttabkeys"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TTabKeys</b></font> = <b>Set</b> <b>of</b> <a href=#ttabkey>TTabKey</a>;</font>
<br>
Set of tabulating key groups, allowed to be used in with a control
(are installed by <a href=tcontrol.htm#looktabkey>TControl.LookTabKey</a> property).
</p>
<a name="tonmessage"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnMessage</b></font> = <b>function</b>( <b>var</b> Msg: TMsg; <b>var</b> Rslt: <b>Integer</b> ): <b>Boolean</b> <b>of</b> <b>object</b>;</font>
<br>
Event type for events, which allows to extend behaviour of windowed controls
descendants using add-ons.
</p>
<a name="toneventaccept"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnEventAccept</b></font> = <b>procedure</b>( Sender: <a href=#pobj>PObj</a>; <b>var</b> Accept: <b>Boolean</b> ) <b>of</b> <b>object</b>;</font>
<br>
Event type for OnClose event.
</p>
<a name="tclosequeryreason"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TCloseQueryReason</b></font> =( qClose, qShutdown, qLogoff );</font>
<br>
Request reason type to call OnClose and OnQueryEndSession.
</p>
<a name="twindowstate"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TWindowState</b></font> =( wsNormal, wsMinimized, wsMaximized );</font>
<br>
Avalable states of <a href=#tcontrol>TControl</a>'s window object.
</p>
<a name="tonsplit"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnSplit</b></font> = <b>function</b>( Sender: <a href=#pcontrol>PControl</a>; NewSize1, NewSize2: <b>Integer</b> ): <b>Boolean</b> <b>of</b> <b>object</b>;</font>
<br>
Event type for OnSplit event handler, designed specially for splitter
control. Event handler must return True to accept new size of previous
(to splitter) control and new size of the rest of client area of parent.
</p>
<a name="tontvbegindrag"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnTVBeginDrag</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; Item: THandle ) <b>of</b> <b>object</b>;</font>
<br>
Event type for OnTVBeginDrag event (defined for tree view control).
</p>
<a name="tontvbeginedit"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnTVBeginEdit</b></font> = <b>function</b>( Sender: <a href=#pcontrol>PControl</a>; Item: THandle ): <b>Boolean</b> <b>of</b> <b>object</b>;</font>
<br>
Event type for OnTVBeginEdit event (for tree view control).
</p>
<a name="tontvendedit"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnTVEndEdit</b></font> = <b>function</b>( Sender: <a href=#pcontrol>PControl</a>; Item: THandle; <b>const</b> NewTxt: KOL_String ): <b>Boolean</b> <b>of</b> <b>object</b>;</font>
<br>
Event type for TOnTVEndEdit event.
</p>
<a name="tontvexpanding"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnTVExpanding</b></font> = <b>function</b>( Sender: <a href=#pcontrol>PControl</a>; Item: THandle; Expand: <b>Boolean</b> ): <b>Boolean</b> <b>of</b> <b>object</b>;</font>
<br>
Event type for TOnTVExpanding event.
</p>
<a name="tontvexpanded"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnTVExpanded</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; Item: THandle; Expand: <b>Boolean</b> ) <b>of</b> <b>object</b>;</font>
<br>
Event type for OnTVExpanded event.
</p>
<a name="tontvdelete"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnTVDelete</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; Item: THandle ) <b>of</b> <b>object</b>;</font>
<br>
Event type for OnTVDelete event.
</p>
<a name="tontvselchanging"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnTVSelChanging</b></font> = <b>function</b>( Sender: <a href=#pcontrol>PControl</a>; oldItem, newItem: THandle ): <b>Boolean</b> <b>of</b> <b>object</b>;</font>
<br>
When the handler returns False, selection is not changed.
</p>
<a name="tondrag"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnDrag</b></font> = <b>function</b>( Sender: <a href=#pcontrol>PControl</a>; ScrX, ScrY: <b>Integer</b>; <b>var</b> CursorShape: <b>Integer</b>; <b>var</b> Stop: <b>Boolean</b> ): <b>Boolean</b> <b>of</b> <b>object</b>;</font>
<br>
Event, called during dragging operation (it is initiated
with method Drag, where callback function of type TOnDrag is
passed as a parameter). Callback function receives Stop parameter True,
when operation is finishing. Otherwise, it can set it to True to force
finishing the operation (in such case, returning False means cancelling
drag operation, True - successful drag and in this last case callback is
no more called). During the operation, when input Stop value is False,
callback function can control Cursor shape, and return True, if the operation
can be finished successfully at the given ScrX, ScrY position.
ScrX, ScrY are screen coordinates of the mouse cursor.
</p>
<a name="tcreateparams"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TCreateParams</b></font> = <b>packed</b> <b>record</b></font>
<br>
Record to pass it through CreateSubClass method.
<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">Caption: PKOLChar;</font>
    </td>
    <td valign="top">
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">Style: cardinal;</font>
    </td>
    <td valign="top">
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">ExStyle: cardinal;</font>
    </td>
    <td valign="top">
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">X, Y: <b>Integer</b>;</font>
    </td>
    <td valign="top">
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">Width, Height: <b>Integer</b>;</font>
    </td>
    <td valign="top">
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">WndParent: HWnd;</font>
    </td>
    <td valign="top">
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">Param: <b>Pointer</b>;</font>
    </td>
    <td valign="top">
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">WindowClass: TWndClass;</font>
    </td>
    <td valign="top">
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">WinClassName: array[0.array.63] <b>of</b> KOLChar;</font>
    </td>
    <td valign="top">
    </td>
  </tr>
</table>
<font face="Courier" color="#800080"><b>end</b>;</font>
</p>
<a name="ttextalign"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TTextAlign</b></font> =( taLeft, taRight, taCenter );</font>
<br>
Text alignments available.
</p>
<a name="trichtextalign"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TRichTextAlign</b></font> =( raLeft, raRight, raCenter, raJustify, raInterLetter, raScaled, raGlyphs, raSnapGrid );</font>
<br>
Text alignment styles, available for RichEdit control.
</p>
<a name="tverticalalign"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TVerticalAlign</b></font> =( vaCenter, vaTop, vaBottom );</font>
<br>
Vertical alignments available.
</p>
<a name="tcontrolalign"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TControlAlign</b></font> =( caNone, caLeft, caTop, caRight, caBottom, caClient );</font>
<br>
Control alignments available.
</p>
<a name="tbitbtnoption"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TBitBtnOption</b></font> =( bboImageList, bboNoBorder, bboNoCaption, bboFixed, bboFocusRect );</font>
<br>
Options available for <a href=#newbitbtn>NewBitBtn</a>.
</p>
<a name="tbitbtnoptions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TBitBtnOptions</b></font> = <b>set</b> <b>of</b> <a href=#tbitbtnoption>TBitBtnOption</a>;</font>
<br>
Set of options, available for <a href=#newbitbtn>NewBitBtn</a>.
</p>
<a name="tglyphlayout"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TGlyphLayout</b></font> =( glyphLeft, glyphTop, glyphRight, glyphBottom, glyphOver );</font>
<br>
Layout of glyph (for <a href=#newbitbtn>NewBitBtn</a>). Layout glyphOver means that text is
drawn over glyph.
</p>
<a name="tonbitbtndraw"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnBitBtnDraw</b></font> = <b>function</b>( Sender: <a href=#pcontrol>PControl</a>; BtnState: <b>Integer</b> ): <b>Boolean</b> <b>of</b> <b>object</b>;</font>
<br>
Event type for <a href=tcontrol.htm#onbitbtndraw>TControl.OnBitBtnDraw</a> event (which is called just before
drawing the BitBtn). If handler returns True, there are no drawing occure.
BtnState, passed to a handler, determines current button state and can
be following: 0 - not pressed, 1 - pressed, 2 - disabled, 3 - focused.
Value 4 is reserved for highlight state (then mouse is over it), but
highlighting is provided only if property Flat is set to True (or one
of events OnMouseEnter / OnMouseLeave is assigned to something).
</p>
<a name="tlistviewstyle"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TListViewStyle</b></font> =( lvsIcon, lvsSmallIcon, lvsList, lvsDetail, lvsDetailNoHeader );</font>
<br>
Styles of view for ListView control (see NewListVew).
</p>
<a name="toneditlvitem"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnEditLVItem</b></font> = <b>function</b>( Sender: <a href=#pcontrol>PControl</a>; Idx, Col: <b>Integer</b>; NewText: PKOL_Char ): <b>Boolean</b> <b>of</b> <b>object</b>;</font>
<br>
Event type for OnEndEditLVItem. Return True in handler to accept new text value.
</p>
<a name="tondeletelvitem"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnDeleteLVItem</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; Idx: <b>Integer</b> ) <b>of</b> <b>object</b>;</font>
<br>
Event type for OnDeleteLVItem event.
</p>
<a name="tonlvdata"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnLVData</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; Idx, SubItem: <b>Integer</b>; <b>var</b> Txt: KOL_String; <b>var</b> ImgIdx: <b>Integer</b>; <b>var</b> State: <b>DWORD</b>; <b>var</b> Store: <b>Boolean</b> ) <b>of</b> <b>object</b>;</font>
<br>
Event type for OnLVData event. Used to provide virtual list view control
(i.e. having lvoOwnerData style) with actual data on request. Use parameter
Store as a flag if control should store obtained data by itself or not.
</p>
<a name="toncomparelvitems"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnCompareLVItems</b></font> = <b>function</b>( Sender: <a href=#pcontrol>PControl</a>; Idx1, Idx2: <b>Integer</b> ): <b>Integer</b> <b>of</b> <b>object</b>;</font>
<br>
Event type to compare two items of the list view (while sorting it).
</p>
<a name="tonlvcolumnclick"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnLVColumnClick</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; Idx: <b>Integer</b> ) <b>of</b> <b>object</b>;</font>
<br>
Event type for OnColumnClick event.
</p>
<a name="tonlvstatechange"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnLVStateChange</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; IdxFrom, IdxTo: <b>Integer</b>; OldState, NewState: <b>DWORD</b> ) <b>of</b> <b>object</b>;</font>
<br>
Event type for OnLVStateChange event, called in responce to select/unselect
a single item or items range in list view control).
</p>
<a name="tdrawstates"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TDrawStates</b></font> =( odsSelected, odsGrayed, odsDisabled, odsChecked, odsFocused, odsDefault, odsHotlist, odsInactive, odsNoAccel, odsNoFocusRect, ods400reserved, ods800reserved, odsComboboxEdit, odsMarked, odsIndeterminate );</font>
<br>
Possible draw states.
<br>odsSelected - The menu item's status is selected.
<br>odsGrayed - The item is to be grayed. This bit is used only in a menu.
<br>odsDisabled - The item is to be drawn as disabled.
<br>odsChecked - The menu item is to be checked. This bit is used only in
a menu.
<br>odsFocused - The item has the keyboard focus.
<br>odsDefault - The item is the default item.
<br>odsHotList - <b>Windows 98, Windows 2000:</b> The item is being
hot-tracked, that is, the item will be highlighted when
the mouse is on the item.
<br>odsInactive - <b>Windows 98, Windows 2000:</b> The item is inactive
and the window associated with the menu is inactive.
<br>odsNoAccel - <b>Windows 2000:</b> The control is drawn without the
keyboard accelerator cues.
<br>odsNoFocusRect - <b>Windows 2000:</b> The control is drawn without
focus indicator cues.
<br>odsComboboxEdit - The drawing takes place in the selection field
(edit control) of an owner-drawn combo box.
<br>odsMarked - for Common controls only. The item is marked. The meaning
of this is up to the implementation.
<br>odsIndeterminate - for Common Controls only. The item is in an
indeterminate state.
</p>
<a name="tdrawstate"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TDrawState</b></font> = <b>Set</b> <b>of</b> <a href=#tdrawstates>TDrawStates</a>;</font>
<br>
Set of possible draw states.
</p>
<a name="tondrawitem"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnDrawItem</b></font> = <b>function</b>( Sender: <a href=#pobj>PObj</a>; DC: HDC; <b>const</b> Rect: TRect; ItemIdx: <b>Integer</b>; DrawAction: TDrawAction; ItemState: <a href=#tdrawstate>TDrawState</a> ): <b>Boolean</b> <b>of</b> <b>object</b>;</font>
<br>
Event type for OnDrawItem event (applied to list box, combo box, list view).
</p>
<a name="tonmeasureitem"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnMeasureItem</b></font> = <b>function</b>( Sender: <a href=#pobj>PObj</a>; Idx: <b>Integer</b> ): <b>Integer</b> <b>of</b> <b>object</b>;</font>
<br>
Event type for OnMeasureItem event. The event handler must return height of list box
item as a result.
</p>
<a name="tgetlvitempart"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TGetLVItemPart</b></font> =( lvipBounds, lvipIcon, lvipLabel, lvupIconAndLabel );</font>
<br>
</p>
<a name="twhereposlvitem"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TWherePosLVItem</b></font> =( lvwpOnIcon, lvwpOnLabel, lvwpOnStateIcon, lvwpOnColumn, lvwpOnItem );</font>
<br>
</p>
<a name="tonlvcustomdraw"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnLVCustomDraw</b></font> = <b>function</b>( Sender: <a href=#pcontrol>PControl</a>; DC: HDC; Stage: <b>DWORD</b>; ItemIdx, SubItemIdx: <b>Integer</b>; <b>const</b> Rect: TRect; ItemState: <a href=#tdrawstate>TDrawState</a>; <b>var</b> TextColor, BackColor: TColor ): <b>DWORD</b> <b>of</b> <b>object</b>;</font>
<br>
Event type for OnLVCustomDraw event.
</p>
<a name="tgradientstyle"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TGradientStyle</b></font> =( gsVertical, gsHorizontal, gsRectangle, gsElliptic, gsRombic, gsTopToBottom, gsBottomToTop );</font>
<br>
Gradient fill styles. See also <a href=#tgradientlayout>TGradientLayout</a>.
</p>
<a name="tgradientlayout"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TGradientLayout</b></font> =( glTopLeft, glTop, glTopRight, glLeft, glCenter, glRight, glBottomLeft, glBottom, glBottomRight );</font>
<br>
Position of starting line / point for gradient filling. Depending on
<a href=#tgradientstyle>TGradientStyle</a>, means either position of first line of first rectangle
(ellipse) to be expanded in a loop to fit entire gradient panel area.
</p>
<a name="teditoption"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TEditOption</b></font> =( eoNoHScroll, eoNoVScroll, eoLowercase, eoMultiline, eoNoHideSel, eoOemConvert, eoPassword, eoReadonly, eoUpperCase, eoWantReturn, eoWantTab, eoNumber );</font>
<br>
Available edit options.
<br> Please note, that eoWantTab option just removes TAB key from a list
of keys available to tabulate from the edit control. To provide insertion
of tabulating key, do so in <a href=tcontrol.htm#onchar>TControl.OnChar</a> event handler. Sorry for
inconvenience, but this is because such behaviour is not must in all cases.
See also <a href=tcontrol.htm#edittabchar>TControl.EditTabChar</a> property.
</p>
<a name="teditoptions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TEditOptions</b></font> = <b>Set</b> <b>of</b> <a href=#teditoption>TEditOption</a>;</font>
<br>
Set of available edit options.
</p>
<a name="trichfmtarea"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TRichFmtArea</b></font> =( raSelection, raWord, raAll );</font>
<br>
Characters formatting area for RichEdit.
</p>
<a name="tretextformat"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TRETextFormat</b></font> =( reRTF, reText, rePlainRTF, reRTFNoObjs, rePlainRTFNoObjs, reTextized, reUnicode, reTextUnicode );</font>
<br>
Available formats for transfer RichEdit text using property
<a href=tcontrol.htm#re_text>TControl.RE_Text</a>.
<pre>
reRTF - normal rich text (no transformations)
reText - plain text only (without OLE objects)
reTextized - plain text with text representation of COM objects
rePlainRTF - reRTF without language-specific keywords
reRTFNoObjs - reRTF without OLE objects
rePlainRTFNoObjs - rePlainRTF without OLE objects
reUnicode - stream is 2-byte Unicode characters rather then 1-byte Ansi
</pre>
</p>
<a name="trichunderline"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TRichUnderline</b></font> =( ruSingle, ruWord, ruDouble, ruDotted, ruDash, ruDashDot, ruDashDotDot, ruWave, ruThick, ruHairLine );</font>
<br>
Rich text exteded underline styles (available only for RichEdit v2.0,
and even for RichEdit v2.0 additional styles can not displayed - but
ruDotted under Windows2000 is working).
</p>
<a name="trichtextsizes"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TRichTextSizes</b></font> =( rtsNoUseCRLF, rtsNoPrecise, rtsClose, rtsBytes );</font>
<br>
Options to calculate size of rich text. Available only for RichEdit2.0
or higher.
</p>
<a name="trichtextsize"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TRichTextSize</b></font> = <b>set</b> <b>of</b> <a href=#trichtextsizes>TRichTextSizes</a>;</font>
<br>
Set of all available optioins to calculate rich text size using
property <a href=tcontrol.htm#re_textsize>TControl.RE_TextSize</a>[ options ].
</p>
<a name="trichnumbering"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TRichNumbering</b></font> =( rnNone, rnBullets, rnArabic, rnLLetter, rnULetter, rnLRoman, rnURoman );</font>
<br>
Advanced numbering styles for paragraph (RichEdit).
<pre>
rnNone     - no numbering
rnBullets  - bullets only
rnArabic   - 1, 2, 3, 4, ...
rnLLetter  - a, b, c, d, ...
rnULetter  - A, B, C, D, ...
rnLRoman   - i, ii, iii, iv, ...
rnURoman   - I, II, III, IV, ...
rnNoNumber - do not show any numbers (but numbering is taking place).
</pre>
</p>
<a name="trichnumbrackets"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TRichNumBrackets</b></font> =( rnbRight, rnbBoth, rnbPeriod, rnbPlain, rnbNoNumber );</font>
<br>
Brackets around number:
<pre>
rnbRight   - 1) 2) 3)     - this is default !
rnbBoth    - (1) (2) (3)
rnbPeriod  - 1. 2. 3.
rnbPlain   - 1 2 3
</pre>
</p>
<a name="tborderedge"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TBorderEdge</b></font> =( beLeft, beTop, beRight, beBottom );</font>
<br>
Borders of rectangle.
</p>
<a name="tontestmouseover"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnTestMouseOver</b></font> = <b>function</b>( Sender: <a href=#pcontrol>PControl</a> ): <b>Boolean</b> <b>of</b> <b>object</b>;</font>
<br>
Event type for <a href=tcontrol.htm#ontestmouseover>TControl.OnTestMouseOver</a> event. The handler should
return True, if it dectects, that mouse is over control.
</p>
<a name="tedgestyle"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TEdgeStyle</b></font> =( esRaised, esLowered, esNone, esTransparent, esSolid );</font>
<br>
Edge styles (for panel - see <a href=#newpanel>NewPanel</a>).
esTransparent and esSolid - special styles equivalent to esNone
except GRushControls are used via USE_GRUSH symbol (ToGRush.pas)
</p>
<a name="tlistoption"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TListOption</b></font> =( loNoHideScroll, loNoExtendSel, loMultiColumn, loMultiSelect, loNoIntegralHeight, loNoSel, loSort, loTabstops, loNoStrings, loNoData, loOwnerDrawFixed, loOwnerDrawVariable, loHScroll );</font>
<br>
Options for ListBox (see <a href=#newlistbox>NewListbox</a>).
To use loHScroll, you also have to send LB_SETHORIZONTALEXTENT with a
maximum width of a line in pixels (wParam)!
</p>
<a name="tlistoptions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TListOptions</b></font> = <b>Set</b> <b>of</b> <a href=#tlistoption>TListOption</a>;</font>
<br>
Set of available options for Listbox.
</p>
<a name="tcombooption"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TComboOption</b></font> =( coReadOnly, coNoHScroll, coAlwaysVScroll, coLowerCase, coNoIntegralHeight, coOemConvert, coSort, coUpperCase, coOwnerDrawFixed, coOwnerDrawVariable, coSimple );</font>
<br>
Options for combobox.
</p>
<a name="tcombooptions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TComboOptions</b></font> = <b>Set</b> <b>of</b> <a href=#tcombooption>TComboOption</a>;</font>
<br>
Set of options available for combobox.
</p>
<a name="tprogressbaroption"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TProgressbarOption</b></font> =( pboVertical, pboSmooth );</font>
<br>
Options for progress bar.
</p>
<a name="tprogressbaroptions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TProgressbarOptions</b></font> = <b>set</b> <b>of</b> <a href=#tprogressbaroption>TProgressbarOption</a>;</font>
<br>
Set of options available for progress bar.
</p>
<a name="ttreeviewoption"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TTreeViewOption</b></font> =( tvoNoLines, tvoLinesRoot, tvoNoButtons, tvoEditLabels, tvoHideSel, tvoDragDrop, tvoNoTooltips, tvoCheckBoxes, tvoTrackSelect, tvoSingleExpand, tvoInfoTip, tvoFullRowSelect, tvoNoScroll, tvoNonEvenHeight );</font>
<br>
Tree view options.
</p>
<a name="ttreeviewoptions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TTreeViewOptions</b></font> = <b>set</b> <b>of</b> <a href=#ttreeviewoption>TTreeViewOption</a>;</font>
<br>
Set of tree view options.
</p>
<a name="ttabcontroloption"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TTabControlOption</b></font> =( tcoButtons, tcoFixedWidth, tcoFocusTabs, tcoIconLeft, tcoLabelLeft, tcoMultiline, tcoMultiselect, tcoFitRows, tcoScrollOpposite, tcoBottom, tcoVertical, tcoFlat, tcoHotTrack, tcoBorder, tcoOwnerDrawFixed );</font>
<br>
Options, available for TabControl.
</p>
<a name="ttabcontroloptions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TTabControlOptions</b></font> = <b>set</b> <b>of</b> <a href=#ttabcontroloption>TTabControlOption</a>;</font>
<br>
Set of options, available for TAbControl during its creation (by
<a href=#newtabcontrol>NewTabControl</a> function).
</p>
<a name="ttoolbaroption"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TToolbarOption</b></font> =( tboTextRight, tboTextBottom, tboFlat, tboTransparent, tboWrapable, tboNoDivider, tbo3DBorder, tboCustomErase );</font>
<br>
Toolbar options. When tboFlat is set and toolbar is placed onto panel,
set its property Transparent to TRUE to provide its correct view.
</p>
<a name="ttoolbaroptions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TToolbarOptions</b></font> = <b>Set</b> <b>of</b> <a href=#ttoolbaroption>TToolbarOption</a>;</font>
<br>
Set of toolbar options.
</p>
<a name="tontoolbarbuttonclick"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnToolbarButtonClick</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; BtnID: <b>Integer</b> ) <b>of</b> <b>object</b>;</font>
<br>
Special event type to handle separate toolbar buttons click events.
</p>
<a name="tontbcustomdraw"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnTBCustomDraw</b></font> = <b>function</b>( Sender: <a href=#pcontrol>PControl</a>; <b>var</b> NMCD: TNMTBCustomDraw ): <b>Integer</b> <b>of</b> <b>object</b>;</font>
<br>
Event type for OnTBCustomDraw event.
</p>
<a name="tdatetimepickeroption"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TDateTimePickerOption</b></font> =( dtpoTime, dtpoDateLong, dtpoUpDown, dtpoRightAlign, dtpoShowNone, dtpoParseInput );</font>
<br>
</p>
<a name="tdatetimepickeroptions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TDateTimePickerOptions</b></font> = <b>set</b> <b>of</b> <a href=#tdatetimepickeroption>TDateTimePickerOption</a>;</font>
<br>
</p>
<a name="tdtparseinputevent"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TDTParseInputEvent</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; <b>const</b> UserString: Ansistring; <b>var</b> DateAndTime: TDateTime; <b>var</b> AllowChange: <b>Boolean</b> ) <b>of</b> <b>object</b>;</font>
<br>
</p>
<a name="tondropfiles"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnDropFiles</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; <b>const</b> FileList: KOL_String; <b>const</b> Pt: TPoint ) <b>of</b> <b>object</b>;</font>
<br>
An event type for OnDropFiles event. When the event is occur, FileList
parameter contains a list of files dropped. File names in a list are
separated with #13 character. This allows You to assign it to <a href=#tstrlist>TStrList</a>
object using its property Text (for example):
<p align=left><font face="Courier" color="008080"><b><pre>
 <font color="800000"><b>procedure</b></font> TSomeObject.DropFiles( Sender: <a href="kol_pas.htm#pcontrol target="_top""><font color="008080">PControl</font></a>; <font color="800000"><b>const</b></font> FileList: AnsiString;
           <font color="800000"><b>const</b></font> Pt: TPoint ); )
 <font color="800000"><b>var</b></font> FList: PStrList;
     I: <font color="800000"><b>Integer</b></font>;
 <font color="800000"><b>begin</b></font>
   FList := <a href="kol_pas.htm#newstrlist target="_top""><font color="008080">NewStrList</font></a>;
   FList.Text := FileList;
   <font color="800000"><b>for</b></font> I := 0 <font color="800000"><b>to</b></font> FList.Count-1 <font color="800000"><b>do</b></font>
   <font color="800000"><b>begin</b></font>
     </b><font color="40A040"><em>// do something with FList.Items[ I ]</em></font><b>
   <font color="800000"><b>end</b></font>;
   FList.Free;
 <font color="800000"><b>end</b></font>;
</pre></b></font></p>
</p>
<a name="toolbarbuttonrect"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ToolbarButtonRect</b></font>( Toolbar: <a href=#pcontrol>PControl</a>; BtnID: <b>Integer</b> ): TRect;</font>
<br>
Use this function instead of reading <a href=tcontrol.htm#tbbuttonrect>TControl.TBButtonRect</a>, if you want
to have it working the same way when standard toolbar is used or GRushControl
toolbar provided in ToGRush.pas unit.
</p>
<a name="toolbarsettooltips"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>ToolbarSetTooltips</b></font>( Toolbar: <a href=#pcontrol>PControl</a>; BtnID1st: <b>Integer</b>; <b>const</b> Tooltips: <b>array</b> <b>of</b> PKOLChar );</font>
<br>
Use this function instead of TContol.TBSetTooltips in your project, when
you use ToGRush unit.
</p>
<a name="toolbarbuttonenabled"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ToolbarButtonEnabled</b></font>( Toolbar: <a href=#pcontrol>PControl</a>; BtnID: <b>Integer</b> ): <b>Boolean</b>;</font>
<br>
Use this function instead of reading the property <a href=tcontrol.htm#tbbuttonenabled>TControl.TBButtonEnabled</a>
when tou use ToGRush unit.
</p>
<a name="enabletoolbarbutton"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>EnableToolbarButton</b></font>( Toolbar: <a href=#pcontrol>PControl</a>; BtnID: <b>Integer</b>; Enable: <b>Boolean</b> );</font>
<br>
Use this procedure instead of writing the property <a href=tcontrol.htm#tbbuttonenabled>TControl.TBButtonEnabled</a>
when you use ToGRush unit.
</p>
<a name="toolbarbuttonvisible"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ToolbarButtonVisible</b></font>( Toolbar: <a href=#pcontrol>PControl</a>; BtnID: <b>Integer</b> ): <b>Boolean</b>;</font>
<br>
Use this function instead of reading the property <a href=tcontrol.htm#tbbuttonvisible>TControl.TBButtonVisible</a>
when tou use ToGRush unit.
</p>
<a name="showhidetoolbarbutton"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>ShowHideToolbarButton</b></font>( Toolbar: <a href=#pcontrol>PControl</a>; BtnID: <b>Integer</b>; Show: <b>Boolean</b> );</font>
<br>
Use this procedure instead of writing the property <a href=tcontrol.htm#tbbuttonvisible>TControl.TBButtonVisible</a>
when you use ToGRush unit.
</p>
<a name="toolbarbuttonchecked"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ToolbarButtonChecked</b></font>( Toolbar: <a href=#pcontrol>PControl</a>; BtnID: <b>Integer</b> ): <b>Boolean</b>;</font>
<br>
</p>
<a name="toolbarbuttonsetchecked"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>ToolbarButtonSetChecked</b></font>( Toolbar: <a href=#pcontrol>PControl</a>; BtnID: <b>Integer</b>; Checked: <b>Boolean</b> );</font>
<br>
</p>
<a name="tonpaintbkgnd"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnPaintBkgnd</b></font> = <b>procedure</b>( Sender: <a href=#pcontrol>PControl</a>; DC: HDC; Rect: PRect );</font>
<br>
Global event definition. Used to define Global_OnPaintBackground
event placeholder.
</p>
<a name="global_onpaintbkgnd"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>Global_OnPaintBkgnd</b></font>: <a href=#tonpaintbkgnd>TOnPaintBkgnd</a> = DefaultPaintBackground;</font>
<br>
Global event. It is assigned in XBackgounds.pas add-on to replace
PaintBackground method for all TVisual objects, allowing great
visualization effect: transparent controls over [animated] bitmap
background. Idea:
 <a href=mailto:"bw@sunv.com">Wei&nbsp;Bao</a>. Implementation:
 <a href=mailto:"bonanzas@xcl.cjb.net">Kladov&nbsp;Vladimir</a>.
</p>
<a name="getshiftstate"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetShiftState</b></font>: <b>DWORD</b>;</font>
<br>
Returns shift state.
</p>
<a name="autominimizeapplet"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>AutoMinimizeApplet</b></font>( Self_: <a href=#pcontrol>PControl</a>; <b>var</b> Msg: TMsg; <b>var</b> Rslt: <b>Integer</b> ): <b>Boolean</b>;</font>
<br>
By Sergey Shishmintzev.
Attach this handler to your modal dialog form handle to provide automatic
minimization of all other forms in the application together with the dialog.
</p>
<a name="helpfilepath"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>HelpFilePath</b></font>: PAnsiChar;</font>
<br>
Path to application help file. If not assigned, application path with
extension replaced to '.hlp' used. To use '.chm' file (HtmlHelp),
call AssignHtmlHelp with a path to a html help file (or a name).
</p>
<a name="htmlhelpcommand"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>HtmlHelpCommand</b></font>( Wnd: HWnd; <b>const</b> <a href=#helpfilepath>HelpFilePath</a>: AnsiString; Cmd, Data: <b>Integer</b> );</font>
<br>
Use this wrapper procedure to call HtmlHelp API function.
</p>
<a name="thhnnotify"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>THHNNotify</b></font> = tagHHN_NOTIFY;</font>
<br>
* Use by command HH_DISPLAY_TEXT_POPUP
</p>
<a name="thhpopup"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>THHPopup</b></font> = tagHH_POPUP;</font>
<br>
* Use by commands - HH_ALINK_LOOKUP, HH_KEYWORD_LOOKUP
</p>
<a name="global_getctlbrushhandle"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>Global_GetCtlBrushHandle</b></font>: <b>function</b>( Sender: <a href=#pcontrol>PControl</a> ): HBrush = SimpleGetCtlBrushHandle;</font>
<br>
Is called to obtain brush handle.
</p>
<a name="global_align"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>Global_Align</b></font>: <b>procedure</b>( Sender: <a href=#pobj>PObj</a> ) = DummyObjProc;</font>
<br>
Is set to perform aligning of control, and only if property Align
is changed for <a href=#tcontrol>TControl</a>, or SetAlign method is called for it.
</p>
<a name="wndfunc"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WndFunc</b></font>( W: HWnd; Msg: Cardinal; wParam, lParam: <b>Integer</b> ): <b>Integer</b>; stdcall;</font>
<br>
Global message handler for window. Redirects all messages to
destination windows, obtaining target <a href=#tcontrol>TControl</a> object address from
window itself, using GetProp API call.
</p>
<a name="appletrunning"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>AppletRunning</b></font>: <b>Boolean</b>;</font>
<br>
Is set to True while message loop is processing (in <a href=#run>Run</a> procedure).
</p>
<a name="appletterminated"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>AppletTerminated</b></font>: <b>Boolean</b>;</font>
<br>
Is set to True when message loop is terminated.
</p>
<a name="applet"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>Applet</b></font>: <a href=#pcontrol>PControl</a>;</font>
<br>
Applet window object. Actually, can be set to main form if program
not needed in special applet button window (useful to make applet
button invisible on taskbar, or to have several forms with single
applet button - crete it in that case using <a href=#newapplet>NewApplet</a>).
</p>
<a name="appbuttonused"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>AppButtonUsed</b></font>: <b>Boolean</b>;</font>
<br>
True if special window to represent applet button (may be invisible)
is used. If no, every form is represented with its own taskbar button
(always visible).
</p>
<a name="screencursor"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ScreenCursor</b></font>: HCursor;</font>
<br>
Set this global variable to override any cursor settings of current
form or control.
</p>
<a name="screenwidth"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ScreenWidth</b></font>: <b>Integer</b>;</font>
<br>
Returns screen width in pixels.
</p>
<a name="screenheight"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ScreenHeight</b></font>: <b>Integer</b>;</font>
<br>
Returns screen height in pixels.
</p>
<a name="tstatusoption"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TStatusOption</b></font> =( soNoSizeGrip, soTop );</font>
<br>
Options available for status bars.
</p>
<a name="tstatusoptions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TStatusOptions</b></font> = <b>Set</b> <b>of</b> <a href=#tstatusoption>TStatusOption</a>;</font>
<br>
Status bar options.
</p>
<a name="drawformattedtext"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>DrawFormattedText</b></font>( Ctl: <a href=#pcontrol>PControl</a>; DC: HDC; <b>var</b> R: TRect; Flags: <b>DWORD</b> );</font>
<br>
This procedure can be useful to draw control's text in custom-defined controls.
</p>
<a name="drawformattedtextxp"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>DrawFormattedTextXP</b></font>( Theme: THandle; Ctl: <a href=#pcontrol>PControl</a>; DC: HDC; <b>var</b> R: TRect; CtlType, CtlStates, Flags1, Flags2: <b>Integer</b> );</font>
<br>
This procedure can be useful to draw control's text in custom-defined controls.
</p>
<a name="_newgraphctl"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>_NewGraphCtl</b></font>( AParent: <a href=#pcontrol>PControl</a>; ATabStop: <b>Boolean</b> ): <a href=#pcontrol>PControl</a>;</font>
<br>
Creates graphic control basics.
</p>
<a name="newgraphlabel"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewGraphLabel</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> ACaption: AnsiString ): <a href=#pcontrol>PControl</a>;</font>
<br>
Creates graphic label, which does not require a window handle.
</p>
<a name="newwordwrapgraphlabel"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewWordWrapGraphLabel</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> ACaption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
Creates graphic label, which does not require a window handle.
</p>
<a name="newgraphpaintbox"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewGraphPaintBox</b></font>( AParent: <a href=#pcontrol>PControl</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
Creates graphic paint box (just the same as graphic label, but with empty Caption).
</p>
<a name="newgraphcheckbox"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewGraphCheckBox</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> ACaption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
Creates graphic checkbox.
</p>
<a name="newgraphradiobox"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewGraphRadioBox</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> ACaption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
Creates graphic radiobox.
</p>
<a name="newgraphbutton"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewGraphButton</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> ACaption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
Creates graphic button.
</p>
<a name="newgrapheditbox"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewGraphEditbox</b></font>( AParent: <a href=#pcontrol>PControl</a>; Options: <a href=#teditoptions>TEditOptions</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
Creates graphic edit box. To do editing, this box should be replaced with
real edit box with a handle (actually, it is enough to place an edit box
on the same Parent having the same BoundsRect).
</p>
<a name="run"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>Run</b></font>( <b>var</b> AppletWnd: <a href=#pcontrol>PControl</a> );</font>
<br>
 <a name="appbutton">
Call this procedure to process messages loop of your program.
Pass here pointer to applet button object (if You have created it
- see <a href=#newapplet>NewApplet</a>) or your main form object of type <a href=#pcontrol>PControl</a> (created
using <a href=#newform>NewForm</a>).
<br><br>
<h1 align=center><font color=#FF8040><a name="visual_objects_constructors"></a>
Visual objects constructing functions
</font></h1>
Following constructing functions for visual controls are available:
<table border=0>
<tr><td><a href="kol_pas.htm#newapplet" target=_top>NewApplet</a></td><td>function NewApplet( const Caption: KOLString ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newform" target=_top>NewForm</a></td><td>function NewForm( AParent: PControl; const Caption: KOLString ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newbutton" target=_top>NewButton</a></td><td>function NewButton( AParent: PControl; const Caption: KOLString ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newbitbtn" target=_top>NewBitBtn</a></td><td>function NewBitBtn( AParent: PControl; const Caption: KOLString; Options: TBitBtnOptions; Layout: TGlyphLayout; GlyphBitmap: HBitmap; GlyphCount: Integer ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newlabel" target=_top>NewLabel</a></td><td>function NewLabel( AParent: PControl; const Caption: KOLString ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newwordwraplabel" target=_top>NewWordWrapLabel</a></td><td>function NewWordWrapLabel( AParent: PControl; const Caption: KOLString ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newlabeleffect" target=_top>NewLabelEffect</a></td><td>function NewLabelEffect( AParent: PControl; const Caption: KOLString; ShadowDeep: Integer ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newpaintbox" target=_top>NewPaintbox</a></td><td>function NewPaintbox( AParent: PControl ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newimageshow" target=_top>NewImageShow</a></td><td>function NewImageShow( AParent: PControl; AImgList: PImageList; ImgIdx: Integer ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newscrollbar" target=_top>NewScrollBar</a></td><td>function NewScrollBar( AParent: PControl; BarSide: TScrollerBar ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newscrollbox" target=_top>NewScrollBox</a></td><td>function NewScrollBox( AParent: PControl; EdgeStyle: TEdgeStyle; Bars: TScrollerBars ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newscrollboxex" target=_top>NewScrollBoxEx</a></td><td>function NewScrollBoxEx( AParent: PControl; EdgeStyle: TEdgeStyle ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newgradientpanel" target=_top>NewGradientPanel</a></td><td>function NewGradientPanel( AParent: PControl; Color1, Color2: TColor ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newgradientpanelex" target=_top>NewGradientPanelEx</a></td><td>function NewGradientPanelEx( AParent: PControl; Color1, Color2: TColor; Style: TGradientStyle; Layout: TGradientLayout ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newpanel" target=_top>NewPanel</a></td><td>function NewPanel( AParent: PControl; EdgeStyle: TEdgeStyle ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newmdiclient" target=_top>NewMDIClient</a></td><td>function NewMDIClient( AParent: PControl; WindowMenu: THandle ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newmdichild" target=_top>NewMDIChild</a></td><td>function NewMDIChild( AParent: PControl; const ACaption: KOLString ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newsplitter" target=_top>NewSplitter</a></td><td>function NewSplitter( AParent: PControl; MinSizePrev, MinSizeNext: Integer ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newsplitterex" target=_top>NewSplitterEx</a></td><td>function NewSplitterEx( AParent: PControl; MinSizePrev, MinSizeNext: Integer; EdgeStyle: TEdgeStyle ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newgroupbox" target=_top>NewGroupbox</a></td><td>function NewGroupbox( AParent: PControl; const Caption: KOLString ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newcheckbox" target=_top>NewCheckbox</a></td><td>function NewCheckbox( AParent: PControl; const Caption: KOLString ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newcheckbox3state" target=_top>NewCheckBox3State</a></td><td>function NewCheckBox3State( AParent: PControl; const Caption: KOLString ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newradiobox" target=_top>NewRadiobox</a></td><td>function NewRadiobox( AParent: PControl; const Caption: KOLString ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#neweditbox" target=_top>NewEditbox</a></td><td>function NewEditbox( AParent: PControl; Options: TEditOptions ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newrichedit" target=_top>NewRichEdit</a></td><td>function NewRichEdit( AParent: PControl; Options: TEditOptions ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newrichedit1" target=_top>NewRichEdit1</a></td><td>function NewRichEdit1( AParent: PControl; Options: TEditOptions ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newlistbox" target=_top>NewListbox</a></td><td>function NewListbox( AParent: PControl; Options: TListOptions ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newcombobox" target=_top>NewCombobox</a></td><td>function NewCombobox( AParent: PControl; Options: TComboOptions ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newprogressbar" target=_top>NewProgressbar</a></td><td>function NewProgressbar( AParent: PControl ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newprogressbarex" target=_top>NewProgressbarEx</a></td><td>function NewProgressbarEx( AParent: PControl; Options: TProgressbarOptions ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newlistview" target=_top>NewListView</a></td><td>function NewListView( AParent: PControl; Style: TListViewStyle; Options: TListViewOptions; ImageListSmall, ImageListNormal, ImageListState: PImageList ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newtreeview" target=_top>NewTreeView</a></td><td>function NewTreeView( AParent: PControl; Options: TTreeViewOptions; ImgListNormal, ImgListState: PImageList ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newtabcontrol" target=_top>NewTabControl</a></td><td>function NewTabControl( AParent: PControl; const Tabs: array of PKOLChar; Options: TTabControlOptions; ImgList: PImageList; ImgList1stIdx: Integer ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newtabempty" target=_top>NewTabEmpty</a></td><td>function NewTabEmpty( AParent: PControl; Options: TTabControlOptions; ImgList: PImageList ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newtoolbar" target=_top>NewToolbar</a></td><td>function NewToolbar( AParent: PControl; Align: TControlAlign; Options: TToolbarOptions; Bitmap: HBitmap; const Buttons: array of PKOLChar; const BtnImgIdxArray: array of Integer ): PControl;</td></tr>
<tr><td><a href="kol_pas.htm#newdatetimepicker" target=_top>NewDateTimePicker</a></td><td>function NewDateTimePicker( AParent: PControl; Options: TDateTimePickerOptions ): PControl;</td></tr>
</table>
</p>
<a name="appletminimize"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>AppletMinimize</b></font>;</font>
<br>
Minimizes the application (<a href=#applet>Applet</a> should be assigned to have effect).
</p>
<a name="applethide"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>AppletHide</b></font>;</font>
<br>
Minimizes and hides application.
</p>
<a name="appletrestore"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>AppletRestore</b></font>;</font>
<br>
Restores <a href=#applet>Applet</a> when minimized.
</p>
<a name="registeridlehandler"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>RegisterIdleHandler</b></font>( <b>const</b> OnIdle: <a href=#tonevent>TOnEvent</a> );</font>
<br>
Registers new Idle handler. Idle handler is called each time when
message queue becomes empty.
</p>
<a name="unregisteridlehandler"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>UnRegisterIdleHandler</b></font>( <b>const</b> OnIdle: <a href=#tonevent>TOnEvent</a> );</font>
<br>
Unregisters Idle handler.
</p>
<a name="initcommoncontrols"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>InitCommonControls</b></font>; stdcall;</font>
<br>
</p>
<a name="doinitcommoncontrols"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>DoInitCommonControls</b></font>( dwICC: <b>DWORD</b> );</font>
<br>
Calls extended initialization for Common Controls (from ComCtrl32).
Pass one of following constants:
<pre>
ICC_LISTVIEW_CLASSES   = $00000001; // listview, header
ICC_TREEVIEW_CLASSES   = $00000002; // treeview, tooltips
ICC_BAR_CLASSES        = $00000004; // toolbar, statusbar, trackbar, tooltips
ICC_TAB_CLASSES        = $00000008; // tab, tooltips
ICC_UPDOWN_CLASS       = $00000010; // updown
ICC_PROGRESS_CLASS     = $00000020; // progress
ICC_HOTKEY_CLASS       = $00000040; // hotkey
ICC_ANIMATE_CLASS      = $00000080; // animate
ICC_WIN95_CLASSES      = $000000FF;
ICC_DATE_CLASSES       = $00000100; // month picker, date picker, time picker, updown
ICC_USEREX_CLASSES     = $00000200; // comboex
ICC_COOL_CLASSES       = $00000400; // rebar (coolbar) control
ICC_INTERNET_CLASSES   = $00000800;
ICC_PAGESCROLLER_CLASS = $00001000; // page scroller
ICC_NATIVEFNTCTL_CLASS = $00002000; // native font control
</pre>
</p>
<a name="oleinit"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>OleInit</b></font>: <b>Boolean</b>;</font>
<br>
Calls OleInitialize (once - all other calls are simulated by incrementing
call counter. Every OleInit shoud be complemented with correspondent OleUninit.
(Though, it is possible to call API function OleUnInitialize once to
cancel all OleInit calls).
</p>
<a name="oleuninit"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>OleUnInit</b></font>;</font>
<br>
Decrements counter and calls OleUnInitialize when it is zeroed.
</p>
<a name="stringtoolestr"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StringToOleStr</b></font>( <b>const</b> Source: Ansistring ): PWideChar;</font>
<br>
</p>
<a name="newapplet"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewApplet</b></font>( <b>const</b> Caption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates applet button window, which has to be parent of all other forms
in your project (but this is *not must*). See also comments about <a href=#newform>NewForm</a>.
<br>
Following methods, properties and events are useful to work with applet
control:
<table border=0>
<tr><td><a href="kol_pas.htm#run" target=_top>Run</a></td><td>procedure Run( var AppletWnd: PControl );</td></tr>
<tr><td><a href="tcontrol.htm#onmessage" target=_top>OnMessage</a></td><td>property OnMessage: TOnMessage;</td></tr>
<tr><td><a href="tcontrol.htm#close" target=_top>Close</a></td><td>procedure Close;</td></tr>
<tr><td><a href="tcontrol.htm#iconload" target=_top>IconLoad</a></td><td>procedure IconLoad( Inst: Integer; ResName: PKOLChar );</td></tr>
<tr><td><a href="tcontrol.htm#iconloadcursor" target=_top>IconLoadCursor</a></td><td>procedure IconLoadCursor( Inst: Integer; ResName: PKOLChar );</td></tr>
<tr><td><a href="tcontrol.htm#show" target=_top>Show</a></td><td>procedure Show;</td></tr>
<tr><td><a href="tcontrol.htm#hide" target=_top>Hide</a></td><td>procedure Hide;</td></tr>
<tr><td><a href="tcontrol.htm#ismainwindow" target=_top>IsMainWindow</a></td><td>function IsMainWindow: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#processmessage" target=_top>ProcessMessage</a></td><td>function ProcessMessage: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#processmessages" target=_top>ProcessMessages</a></td><td>procedure ProcessMessages;</td></tr>
<tr><td><a href="tcontrol.htm#processpendingmessages" target=_top>ProcessPendingMessages</a></td><td>procedure ProcessPendingMessages;</td></tr>
<tr><td><a href="tcontrol.htm#icon" target=_top>Icon</a></td><td>property Icon: HIcon;</td></tr>
<tr><td><a href="tcontrol.htm#caption" target=_top>Caption</a></td><td>property Caption: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#modalform" target=_top>ModalForm</a></td><td>property ModalForm: PControl;</td></tr>
</table>
</p>
<a name="newform"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewForm</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> Caption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates form window object and returns pointer to it. If You use only one form,
and You are not going to do applet button on task bar invisible, it is not
necessary to create also special applet button window - just pass
your (main) form object to <a href=#run>Run</a> procedure. In that case, it is a good
idea to assign pointer to your main form object to <a href=#applet>Applet</a> variable
immediately following creating it - because some objects (e.g. <a href=#ttimer>TTimer</a>)
want to have <a href=#applet>Applet</a> assigned to something.
<br>
Following methods, properties and events are useful to work with forms
(ones common for all visual objects, such as
<a href="tcontrol.htm#Left" target=_top> Left </a>
,
<a href="tcontrol.htm#Top" target=_top> Top </a>
,
<a href="tcontrol.htm#Width" target=_top> Width </a>
,
<a href="tcontrol.htm#Height" target=_top> Height </a>
, etc. are not listed here - look <a href=#tcontrol>TControl</a> for it):
<table border=0>
<tr><td><a href="tcontrol.htm#onmessage" target=_top>OnMessage</a></td><td>property OnMessage: TOnMessage;</td></tr>
<tr><td><a href="tcontrol.htm#onclose" target=_top>OnClose</a></td><td>property OnClose: TOnEventAccept;</td></tr>
<tr><td><a href="tcontrol.htm#onqueryendsession" target=_top>OnQueryEndSession</a></td><td>property OnQueryEndSession: TOnEventAccept;</td></tr>
<tr><td><a href="tcontrol.htm#onminimize" target=_top>OnMinimize</a></td><td>property OnMinimize: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#onmaximize" target=_top>OnMaximize</a></td><td>property OnMaximize: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#onrestore" target=_top>OnRestore</a></td><td>property OnRestore: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#onformclick" target=_top>OnFormClick</a></td><td>property OnFormClick: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#fmodalresult" target=_top>fModalResult</a></td><td>fModalResult;</td></tr>
<tr><td><a href="tcontrol.htm#parentform" target=_top>ParentForm</a></td><td>function ParentForm: PControl;</td></tr>
<tr><td><a href="tcontrol.htm#createwindow" target=_top>CreateWindow</a></td><td>function CreateWindow: Boolean; virtual;</td></tr>
<tr><td><a href="tcontrol.htm#close" target=_top>Close</a></td><td>procedure Close;</td></tr>
<tr><td><a href="tcontrol.htm#iconload" target=_top>IconLoad</a></td><td>procedure IconLoad( Inst: Integer; ResName: PKOLChar );</td></tr>
<tr><td><a href="tcontrol.htm#iconloadcursor" target=_top>IconLoadCursor</a></td><td>procedure IconLoadCursor( Inst: Integer; ResName: PKOLChar );</td></tr>
<tr><td><a href="tcontrol.htm#show" target=_top>Show</a></td><td>procedure Show;</td></tr>
<tr><td><a href="tcontrol.htm#showmodal" target=_top>ShowModal</a></td><td>function ShowModal: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#hide" target=_top>Hide</a></td><td>procedure Hide;</td></tr>
<tr><td><a href="tcontrol.htm#minimizenormalanimated" target=_top>MinimizeNormalAnimated</a></td><td>procedure MinimizeNormalAnimated;</td></tr>
<tr><td><a href="tcontrol.htm#restorenormalmaximized" target=_top>RestoreNormalMaximized</a></td><td>procedure RestoreNormalMaximized;</td></tr>
<tr><td><a href="tcontrol.htm#ismainwindow" target=_top>IsMainWindow</a></td><td>function IsMainWindow: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#gotocontrol" target=_top>GotoControl</a></td><td>procedure GotoControl( Key: DWORD );</td></tr>
<tr><td><a href="tcontrol.htm#removestatus" target=_top>RemoveStatus</a></td><td>procedure RemoveStatus;</td></tr>
<tr><td><a href="tcontrol.htm#statuspanelcount" target=_top>StatusPanelCount</a></td><td>function StatusPanelCount: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#icon" target=_top>Icon</a></td><td>property Icon: HIcon;</td></tr>
<tr><td><a href="tcontrol.htm#caption" target=_top>Caption</a></td><td>property Caption: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#modal" target=_top>Modal</a></td><td>property Modal: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#modalform" target=_top>ModalForm</a></td><td>property ModalForm: PControl;</td></tr>
<tr><td><a href="tcontrol.htm#windowstate" target=_top>WindowState</a></td><td>property WindowState: TWindowState;</td></tr>
<tr><td><a href="tcontrol.htm#hasborder" target=_top>HasBorder</a></td><td>property HasBorder: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#hascaption" target=_top>HasCaption</a></td><td>property HasCaption: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#canresize" target=_top>CanResize</a></td><td>property CanResize: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#stayontop" target=_top>StayOnTop</a></td><td>property StayOnTop: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#border" target=_top>Border</a></td><td>property Border: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#margin" target=_top>Margin</a></td><td>property Margin: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#alphablend" target=_top>AlphaBlend</a></td><td>property AlphaBlend: Byte;</td></tr>
<tr><td><a href="tcontrol.htm#statustext" target=_top>StatusText</a></td><td>property StatusText[ Idx: Integer ]: PKOLChar;</td></tr>
<tr><td><a href="tcontrol.htm#simplestatustext" target=_top>SimpleStatusText</a></td><td>property SimpleStatusText: PKOLChar;</td></tr>
<tr><td><a href="tcontrol.htm#statuspanelrightx" target=_top>StatusPanelRightX</a></td><td>property StatusPanelRightX[ Idx: Integer ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#statuswindow" target=_top>StatusWindow</a></td><td>property StatusWindow: HWND;</td></tr>
</table>
</p>
<a name="newbutton"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewButton</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> Caption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates button on given parent control or form.
Please note, that in Windows, buttons can not change its
<a href="tcontrol.htm#Font" target=_top> Font </a>
color
and to be
<a href="tcontrol.htm#Transparent" target=_top> Transparent </a>
.
<br> Following methods, properies and events are (especially) useful with
a button:
<table border=0>
<tr><td><a href="tcontrol.htm#onclick" target=_top>OnClick</a></td><td>property OnClick: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#setbuttonicon" target=_top>SetButtonIcon</a></td><td>function SetButtonIcon( aIcon: HIcon ): PControl;</td></tr>
<tr><td><a href="tcontrol.htm#setbuttonbitmap" target=_top>SetButtonBitmap</a></td><td>function SetButtonBitmap( aBmp: HBitmap ): PControl;</td></tr>
<tr><td><a href="tcontrol.htm#likespeedbutton" target=_top>LikeSpeedButton</a></td><td>function LikeSpeedButton: PControl;</td></tr>
<tr><td><a href="tcontrol.htm#click" target=_top>Click</a></td><td>procedure Click;</td></tr>
<tr><td><a href="tcontrol.htm#caption" target=_top>Caption</a></td><td>property Caption: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#defaultbtn" target=_top>DefaultBtn</a></td><td>property DefaultBtn: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#cancelbtn" target=_top>CancelBtn</a></td><td>property CancelBtn: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#textalign" target=_top>TextAlign</a></td><td>property TextAlign: TTextAlign;</td></tr>
<tr><td><a href="tcontrol.htm#verticalalign" target=_top>VerticalAlign</a></td><td>property VerticalAlign: TVerticalAlign;</td></tr>
</table>
</p>
<a name="newbitbtn"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewBitBtn</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> Caption: KOLString; Options: <a href=#tbitbtnoptions>TBitBtnOptions</a>; Layout: <a href=#tglyphlayout>TGlyphLayout</a>; GlyphBitmap: HBitmap; GlyphCount: <b>Integer</b> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates image button (actually implemented as owner-drawn). In Options,
it is possible to determine, whether bitmap or image list used to contain
one or more (up to 5) images, correspondent to certain BitBtn state.
<br>&nbsp;&nbsp;&nbsp;
For case of imagelist (option bboImageList), it is possible to use a
number of glyphs from the image list, starting from image index given
by GlyphCount parameter. Number of used glyphs is passed in that case
in high word of GlyphCount parameter (if 0, one image is used therefore).
For bboImageList, BitBtn can be Transparent (and in that case bboNoBorder
style can be useful to draw custom buttons of non-rectangular shape).
<br>&nbsp;&nbsp;&nbsp;
For case of bitmap BitBtn, image is stretched down (if too big), but can
not be transparent. It is not necessary for bitmap BitBtn to pass correct
GlyphCount - it is calculated on base of bitmap size, if 0 is passed.
<br>&nbsp;&nbsp;&nbsp;
And, certainly, BitBtn can be without glyph image (text only). For that
case, it is therefore is more flexible and power than usual Button (but
requires more code). E.g., BitBtn can change its
<a href="tcontrol.htm#Font" target=_top> Font </a>
,
<a href="tcontrol.htm#Color" target=_top> Color </a>
,
and to be totally
<a href="tcontrol.htm#Transparent" target=_top> Transparent </a>
.
Moreover, BitBtn can be
<a href="tcontrol.htm#Flat" target=_top> Flat </a>
, bboFixed,
<a href="tcontrol.htm#SpeedButton" target=_top> SpeedButton </a>
and
have property
<a href="tcontrol.htm#RepeatInterval" target=_top> RepeatInterval </a>
.
<br>&nbsp;&nbsp;&nbsp;
Note: if You use bboFixed Style, use OnChange event instead of OnClick,
because
<a href="tcontrol.htm#Checked" target=_top> Checked </a>
state is changed immediately however OnClick occure
only when mouse or space key released (and can be not called at all if
mouse button is released out of BitBtn bounds). Also, bboFixed defines
only which glyph to show (the border if it is not turned off behaves as
usual for a button, i.e. it becomes lowered and then raised again at any click).
Here You can find references to other properties, events and methods
applicable to BitBtn:
<table border=0>
<tr><td><a href="tcontrol.htm#onbitbtndraw" target=_top>OnBitBtnDraw</a></td><td>property OnBitBtnDraw: TOnBitBtnDraw;</td></tr>
<tr><td><a href="tcontrol.htm#ontestmouseover" target=_top>OnTestMouseOver</a></td><td>property OnTestMouseOver: TOnTestMouseOver;</td></tr>
<tr><td><a href="tcontrol.htm#likespeedbutton" target=_top>LikeSpeedButton</a></td><td>function LikeSpeedButton: PControl;</td></tr>
<tr><td><a href="tcontrol.htm#caption" target=_top>Caption</a></td><td>property Caption: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#bitbtndrawmnemonic" target=_top>BitBtnDrawMnemonic</a></td><td>property BitBtnDrawMnemonic: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#textshiftx" target=_top>TextShiftX</a></td><td>property TextShiftX: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#textshifty" target=_top>TextShiftY</a></td><td>property TextShiftY: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#bitbtnimgidx" target=_top>BitBtnImgIdx</a></td><td>property BitBtnImgIdx: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#bitbtnimglist" target=_top>BitBtnImgList</a></td><td>property BitBtnImgList: THandle;</td></tr>
<tr><td><a href="tcontrol.htm#defaultbtn" target=_top>DefaultBtn</a></td><td>property DefaultBtn: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#cancelbtn" target=_top>CancelBtn</a></td><td>property CancelBtn: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#textalign" target=_top>TextAlign</a></td><td>property TextAlign: TTextAlign;</td></tr>
<tr><td><a href="tcontrol.htm#mouseincontrol" target=_top>MouseInControl</a></td><td>property MouseInControl: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#flat" target=_top>Flat</a></td><td>property Flat: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#repeatinterval" target=_top>RepeatInterval</a></td><td>property RepeatInterval: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#imagelistnormal" target=_top>ImageListNormal</a></td><td>property ImageListNormal: PImageList;</td></tr>
</table>
</p>
<a name="newlabel"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewLabel</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> Caption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates static text control (native Windows STATIC control).
Use property
<a href="tcontrol.htm#Caption" target=_top> Caption </a>
at run time to change label text. Also
it is possible to adjust label
<a href="tcontrol.htm#Font" target=_top> Font </a>
,
<a href="tcontrol.htm#Brush" target=_top> Brush </a>
or
<a href="tcontrol.htm#Color" target=_top> Color </a>
.
Label can be
<a href="tcontrol.htm#Transparent" target=_top> Transparent </a>
. If You want to have rotated text
label, call <a href=#newlabeleffect>NewLabelEffect</a> instead and change its
<a href="tcontrol.htm#Font" target=_top> Font </a>
.FontOrientation.
Other references certain for a label:
<table border=0>
<tr><td><a href="tcontrol.htm#caption" target=_top>Caption</a></td><td>property Caption: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#textalign" target=_top>TextAlign</a></td><td>property TextAlign: TTextAlign;</td></tr>
<tr><td><a href="tcontrol.htm#verticalalign" target=_top>VerticalAlign</a></td><td>property VerticalAlign: TVerticalAlign;</td></tr>
</table>
</p>
<a name="newwordwraplabel"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewWordWrapLabel</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> Caption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates multiline static text control (native Windows STATIC control),
which can wrap long text onto several lines. See also <a href=#newlabel>NewLabel</a>.
See also:
<table border=0>
<tr><td><a href="tcontrol.htm#caption" target=_top>Caption</a></td><td>property Caption: KOLString;</td></tr>
</table>
</p>
<a name="newlabeleffect"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewLabelEffect</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> Caption: KOLString; ShadowDeep: <b>Integer</b> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates 3D-label with capability to rotate its text
<a href="tcontrol.htm#Caption" target=_top> Caption </a>
, which
is controlled by changing
<a href="tcontrol.htm#Font" target=_top> Font </a>
.FontOrientation property. If You want
to get flat effect label (e.g. to rotate it only), pass
<a href="tcontrol.htm#ShadowDeep" target=_top> ShadowDeep </a>
= 0.
Please note, that drawing procedure uses
<a href="tcontrol.htm#Canvas" target=_top> Canvas </a>
property, so using of
LabelEffect leads to increase size of executable.
See also:
<table border=0>
<tr><td><a href="tcontrol.htm#caption" target=_top>Caption</a></td><td>property Caption: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#shadowdeep" target=_top>ShadowDeep</a></td><td>property ShadowDeep: Integer;</td></tr>
</table>
</p>
<a name="newpaintbox"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewPaintbox</b></font>( AParent: <a href=#pcontrol>PControl</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates owner-drawn STATIC control. Set its
<a href="tcontrol.htm#OnPaint" target=_top> OnPaint </a>
event to
perform custom painting.
<table border=0>
<tr><td><a href="tcontrol.htm#canvas" target=_top>Canvas</a></td><td>property Canvas: PCanvas;</td></tr>
</table>
</p>
<a name="newimageshow"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewImageShow</b></font>( AParent: <a href=#pcontrol>PControl</a>; AImgList: <a href=#pimagelist>PImageList</a>; ImgIdx: <b>Integer</b> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates an image show control, implemented as a paintbox which is used to
draw an image from the imagelist. At run-time, use property CurIndex to
select another image from the imagelist, and a property ImageListNormal to
use another image list. When the control is created, its size becomes
equal to dimensions of imagelist (if any).
</p>
<a name="newscrollbar"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewScrollBar</b></font>( AParent: <a href=#pcontrol>PControl</a>; BarSide: TScrollerBar ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates simple scroll bar.
</p>
<a name="newscrollbox"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewScrollBox</b></font>( AParent: <a href=#pcontrol>PControl</a>; EdgeStyle: <a href=#tedgestyle>TEdgeStyle</a>; Bars: TScrollerBars ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates simple scrolling box, which can be used any way you wish, e.g. to scroll
certain large image. To provide automatic scrolling of a set of child controls,
use advanced scroll box, created with <a href=#newscrollboxex>NewScrollBoxEx</a>.
</p>
<a name="newscrollboxex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewScrollBoxEx</b></font>( AParent: <a href=#pcontrol>PControl</a>; EdgeStyle: <a href=#tedgestyle>TEdgeStyle</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates extended scrolling box control, which automatically scrolls child
controls (if any).
</p>
<a name="newgradientpanel"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewGradientPanel</b></font>( AParent: <a href=#pcontrol>PControl</a>; Color1, Color2: TColor ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates gradient-filled STATIC control. To adjust colors at the
run time, change
<a href="tcontrol.htm#Color1" target=_top> Color1 </a>
and
<a href="tcontrol.htm#Color2" target=_top> Color2 </a>
properties (which initially are
assigned from Color1, Color2 parameters), and call
<a href="tcontrol.htm#Invalidate" target=_top> Invalidate </a>
method
to repaint control.
</p>
<a name="newgradientpanelex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewGradientPanelEx</b></font>( AParent: <a href=#pcontrol>PControl</a>; Color1, Color2: TColor; Style: <a href=#tgradientstyle>TGradientStyle</a>; Layout: <a href=#tgradientlayout>TGradientLayout</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates gradient-filled STATIC control. To adjust colors at the
run time, change
<a href="tcontrol.htm#Color1" target=_top> Color1 </a>
and
<a href="tcontrol.htm#Color2" target=_top> Color2 </a>
properties (which initially are
assigned from Color1, Color2 parameters), and call
<a href="tcontrol.htm#Invalidate" target=_top> Invalidate </a>
method
to repaint control. Depending on style and first line/point layout, can
looking different. Idea: Vladimir Stojiljkovic.
</p>
<a name="newpanel"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewPanel</b></font>( AParent: <a href=#pcontrol>PControl</a>; EdgeStyle: <a href=#tedgestyle>TEdgeStyle</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates panel, which can be parent for other controls (though, any
control can be used as a parent for other ones, but panel is specially
designed for such purpose).
</p>
<a name="newmdiclient"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewMDIClient</b></font>( AParent: <a href=#pcontrol>PControl</a>; WindowMenu: THandle ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates MDI client window, which is a special type of child window,
containing all MDI child windows, created calling <a href=#newmdichild>NewMDIChild</a> function.
On a form, MDI client behaves like a panel, so it can be placed and sized
(or aligned) like any other controls. To minimize flick during resizing
main form having another aligned controls, place MDI client window on
a panel and align it caClient in the panel.
<br>Note:
MDI client must be a single on the form.
</p>
<a name="newmdichild"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewMDIChild</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> ACaption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates MDI client window. AParent should be a MDI client window,
created with <a href=#newmdiclient>NewMDIClient</a> function.
</p>
<a name="newsplitter"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewSplitter</b></font>( AParent: <a href=#pcontrol>PControl</a>; MinSizePrev, MinSizeNext: <b>Integer</b> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates splitter control, which will separate previous one (i.e. last
created one before splitter on the same parent) from created
next, allowing to user to adjust size of separated controls by dragging
the splitter in desired direction. Created splitter becomes vertical
or horizontal depending on Align style of previous control on the same
parent (if caLeft/caRight then vertical, if caTop/caBottom then horizontal).
<br>&nbsp;&nbsp;&nbsp;
Please note, what if previous control has no Align equal to caLeft/caRight
or caTop/caBottom, splitter will not be able to function normally. If
previous control does not exist, it is yet possible to use splitter as
a resizeable panel (but set its initial Align value first - otherwise it
is not set by default. Also, change Cursor property as You wish in that
case, since it is not set too in case, when previous control does not
exist).
<br>&nbsp;&nbsp;&nbsp;
Additional parameters determine, which minimal size (width or height -
correspondently to split direction) is allowed for left (top) control
and to rest of client area of parent, correspondently. (It is possible
later to set second control for checking its size with MinSizeNext
value - using <a href=tcontrol.htm#secondcontrol>TControl.SecondControl</a> property). If -1 passed,
correspondent control size is not checked during dragging of splitter.
Usually 0 is more suitable value (with this value, it is garantee, that
splitter will be always available even if mouse was released far from the
edge of form).
<br>&nbsp;&nbsp;&nbsp;
It is possible for user to press Escape any time while dragging splitter
to abort all adjustments made starting from left mouse button push and
begin of drag the splitter. But remember please, that such event is
controlled using timer, and therefore correspondent keyboard events
are received by currently focused control. Be sure, that pressing Escape
will not affect to any control on form, which could be focused, otherwise
filter keyboard messages (by yourself) to prevent undesired handling of
Escape key by certain controls while splitting. (Use Dragging property
to check if splitter is dragging by user with mouse).
<br>&nbsp;&nbsp;&nbsp;
See also:
<a href=#newsplitterex>NewSplitterEx</a>
<table border=0>
<tr><td><a href="tcontrol.htm#onsplit" target=_top>OnSplit</a></td><td>property OnSplit: TOnSplit;</td></tr>
<tr><td><a href="tcontrol.htm#minsizeprev" target=_top>MinSizePrev</a></td><td>property MinSizePrev: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#minsizenext" target=_top>MinSizeNext</a></td><td>property MinSizeNext: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#secondcontrol" target=_top>SecondControl</a></td><td>property SecondControl: PControl;</td></tr>
<tr><td><a href="tcontrol.htm#dragging" target=_top>Dragging</a></td><td>property Dragging: Boolean;</td></tr>
</table>
</p>
<a name="newsplitterex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewSplitterEx</b></font>( AParent: <a href=#pcontrol>PControl</a>; MinSizePrev, MinSizeNext: <b>Integer</b>; EdgeStyle: <a href=#tedgestyle>TEdgeStyle</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates splitter control. Difference from <a href=#newsplitter>NewSplitter</a> is what it is possible
to determine if a splitter will be beveled or not. See also <a href=#newsplitter>NewSplitter</a>.
</p>
<a name="newgroupbox"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewGroupbox</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> Caption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates group box control. Note, that to group radio items, group
box is not necessary - any parent can play role of group for radio items.
See also <a href=#newpanel>NewPanel</a>.
</p>
<a name="newcheckbox"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewCheckbox</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> Caption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates check box control. Special properties, methods, events:
<table border=0>
<tr><td><a href="tcontrol.htm#onclick" target=_top>OnClick</a></td><td>property OnClick: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#setchecked" target=_top>SetChecked</a></td><td>function SetChecked( const Value: Boolean ): PControl;</td></tr>
<tr><td><a href="tcontrol.htm#click" target=_top>Click</a></td><td>procedure Click;</td></tr>
<tr><td><a href="tcontrol.htm#checked" target=_top>Checked</a></td><td>property Checked: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#check3" target=_top>Check3</a></td><td>property Check3: TTriStateCheck;</td></tr>
</table>
</p>
<a name="newcheckbox3state"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewCheckBox3State</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> Caption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates check box control with 3 states. Special properties, methods,
events:
<table border=0>
<tr><td><a href="tcontrol.htm#onclick" target=_top>OnClick</a></td><td>property OnClick: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#setchecked" target=_top>SetChecked</a></td><td>function SetChecked( const Value: Boolean ): PControl;</td></tr>
<tr><td><a href="tcontrol.htm#click" target=_top>Click</a></td><td>procedure Click;</td></tr>
<tr><td><a href="tcontrol.htm#checked" target=_top>Checked</a></td><td>property Checked: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#check3" target=_top>Check3</a></td><td>property Check3: TTriStateCheck;</td></tr>
</table>
</p>
<a name="newradiobox"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewRadiobox</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> Caption: KOLString ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates radio box control. Alternative radio items must have the
same parent window (regardless of its kind, either groupbox (<a href=#newgroupbox>NewGroupbox</a>),
panel (<a href=#newpanel>NewPanel</a>) or form itself). Following properties, methods and events
are specially for radiobox controls:
<table border=0>
<tr><td><a href="tcontrol.htm#onclick" target=_top>OnClick</a></td><td>property OnClick: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#setradiochecked" target=_top>SetRadioChecked</a></td><td>function SetRadioChecked: PControl;</td></tr>
<tr><td><a href="tcontrol.htm#setradiocheckedold" target=_top>SetRadioCheckedOld</a></td><td>function SetRadioCheckedOld: PControl;</td></tr>
<tr><td><a href="tcontrol.htm#click" target=_top>Click</a></td><td>procedure Click;</td></tr>
<tr><td><a href="tcontrol.htm#checked" target=_top>Checked</a></td><td>property Checked: Boolean;</td></tr>
</table>
</p>
<a name="neweditbox"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewEditbox</b></font>( AParent: <a href=#pcontrol>PControl</a>; Options: <a href=#teditoptions>TEditOptions</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates edit box control. To create multiline edit box, similar to
TMemo in VCL, apply eoMultiline in Options. Following properties, methods,
events are special for edit controls:
<table border=0>
<tr><td><a href="tcontrol.htm#onchange" target=_top>OnChange</a></td><td>property OnChange: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#selectall" target=_top>SelectAll</a></td><td>procedure SelectAll;</td></tr>
<tr><td><a href="tcontrol.htm#replaceselection" target=_top>ReplaceSelection</a></td><td>procedure ReplaceSelection( const Value: KOLString; aCanUndo: Boolean );</td></tr>
<tr><td><a href="tcontrol.htm#deletelines" target=_top>DeleteLines</a></td><td>procedure DeleteLines( FromLine, ToLine: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#item2pos" target=_top>Item2Pos</a></td><td>function Item2Pos( ItemIdx: Integer ): DWORD;</td></tr>
<tr><td><a href="tcontrol.htm#pos2item" target=_top>Pos2Item</a></td><td>function Pos2Item( Pos: Integer ): DWORD;</td></tr>
<tr><td><a href="tcontrol.htm#saveposition" target=_top>SavePosition</a></td><td>function SavePosition: TEditPositions;</td></tr>
<tr><td><a href="tcontrol.htm#restoreposition" target=_top>RestorePosition</a></td><td>procedure RestorePosition( const p: TEditPositions );</td></tr>
<tr><td><a href="tcontrol.htm#updateposition" target=_top>UpdatePosition</a></td><td>procedure UpdatePosition( var p: TEditPositions; FromPos, CountInsertDelChars, CountInsertDelLines: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#edittabchar" target=_top>EditTabChar</a></td><td>function EditTabChar: PControl;</td></tr>
<tr><td><a href="tcontrol.htm#canundo" target=_top>CanUndo</a></td><td>function CanUndo: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#emptyundobuffer" target=_top>EmptyUndoBuffer</a></td><td>procedure EmptyUndoBuffer;</td></tr>
<tr><td><a href="tcontrol.htm#undo" target=_top>Undo</a></td><td>function Undo: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#text" target=_top>Text</a></td><td>property Text: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#selstart" target=_top>SelStart</a></td><td>property SelStart: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#sellength" target=_top>SelLength</a></td><td>property SelLength: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#selection" target=_top>Selection</a></td><td>property Selection: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#count" target=_top>Count</a></td><td>property Count: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#items" target=_top>Items</a></td><td>property Items[ Idx: Integer ]: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#itemselected" target=_top>ItemSelected</a></td><td>property ItemSelected[ ItemIdx: Integer ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#textalign" target=_top>TextAlign</a></td><td>property TextAlign: TTextAlign;</td></tr>
<tr><td><a href="tcontrol.htm#ed_transparent" target=_top>Ed_Transparent</a></td><td>property Ed_Transparent: Boolean;</td></tr>
</table>
</p>
<a name="newrichedit"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewRichEdit</b></font>( AParent: <a href=#pcontrol>PControl</a>; Options: <a href=#teditoptions>TEditOptions</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates rich text edit control. A rich edit control is a window in which
the user can enter and edit text. The text can be assigned character and
paragraph formatting, and can include embedded OLE objects. Rich edit
controls provide a programming interface for formatting text. However, an
application must implement any user interface components necessary to make
formatting operations available to the user.
<br>&nbsp;&nbsp;&nbsp;
Note: eoPassword, eoMultiline options have no effect for RichEdit control.
Some operations are supersided with special versions of those, created
especially for RichEdit, but in some cases it is necessary to use
another properties and methods, specially designed for RichEdit (see
methods and properties, which names are starting from RE_...).
<br>&nbsp;&nbsp;&nbsp;
Following properties, methods, events are special for edit controls:
<table border=0>
<tr><td><a href="tcontrol.htm#onselchange" target=_top>OnSelChange</a></td><td>property OnSelChange: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#onre_insovrmode_change" target=_top>OnRE_InsOvrMode_Change</a></td><td>property OnRE_InsOvrMode_Change: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#onprogress" target=_top>OnProgress</a></td><td>property OnProgress: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#onre_overurl" target=_top>OnRE_OverURL</a></td><td>property OnRE_OverURL: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#onre_urlclick" target=_top>OnRE_URLClick</a></td><td>property OnRE_URLClick: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#beginupdate" target=_top>BeginUpdate</a></td><td>procedure BeginUpdate;</td></tr>
<tr><td><a href="tcontrol.htm#selectall" target=_top>SelectAll</a></td><td>procedure SelectAll;</td></tr>
<tr><td><a href="tcontrol.htm#replaceselection" target=_top>ReplaceSelection</a></td><td>procedure ReplaceSelection( const Value: KOLString; aCanUndo: Boolean );</td></tr>
<tr><td><a href="tcontrol.htm#deletelines" target=_top>DeleteLines</a></td><td>procedure DeleteLines( FromLine, ToLine: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#re_textsizeprecise" target=_top>RE_TextSizePrecise</a></td><td>function RE_TextSizePrecise: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtstandard" target=_top>RE_FmtStandard</a></td><td>function RE_FmtStandard: PControl;</td></tr>
<tr><td><a href="tcontrol.htm#re_loadfromstream" target=_top>RE_LoadFromStream</a></td><td>function RE_LoadFromStream( Stream: PStream; Length: Integer; Format: TRETextFormat; SelectionOnly: Boolean ): Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_savetostream" target=_top>RE_SaveToStream</a></td><td>function RE_SaveToStream( Stream: PStream; Format: TRETextFormat; SelectionOnly: Boolean ): Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_loadfromfile" target=_top>RE_LoadFromFile</a></td><td>function RE_LoadFromFile( const Filename: KOLString; Format: TRETextFormat; SelectionOnly: Boolean ): Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_savetofile" target=_top>RE_SaveToFile</a></td><td>function RE_SaveToFile( const Filename: KOLString; Format: TRETextFormat; SelectionOnly: Boolean ): Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_hideselection" target=_top>RE_HideSelection</a></td><td>procedure RE_HideSelection( aHide: Boolean );</td></tr>
<tr><td><a href="tcontrol.htm#re_searchtext" target=_top>RE_SearchText</a></td><td>function RE_SearchText( const Value: KOLString; MatchCase, WholeWord, ScanForward: Boolean; SearchFrom, SearchTo: Integer ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_wsearchtext" target=_top>RE_WSearchText</a></td><td>function RE_WSearchText( const Value: WideString; MatchCase, WholeWord, ScanForward: Boolean; SearchFrom, SearchTo: Integer ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_nooledragdrop" target=_top>RE_NoOLEDragDrop</a></td><td>function RE_NoOLEDragDrop: PControl;</td></tr>
<tr><td><a href="tcontrol.htm#canundo" target=_top>CanUndo</a></td><td>function CanUndo: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#emptyundobuffer" target=_top>EmptyUndoBuffer</a></td><td>procedure EmptyUndoBuffer;</td></tr>
<tr><td><a href="tcontrol.htm#undo" target=_top>Undo</a></td><td>function Undo: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_redo" target=_top>RE_Redo</a></td><td>function RE_Redo: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#selstart" target=_top>SelStart</a></td><td>property SelStart: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#sellength" target=_top>SelLength</a></td><td>property SelLength: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#selection" target=_top>Selection</a></td><td>property Selection: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#count" target=_top>Count</a></td><td>property Count: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#items" target=_top>Items</a></td><td>property Items[ Idx: Integer ]: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#maxtextsize" target=_top>MaxTextSize</a></td><td>property MaxTextSize: DWORD;</td></tr>
<tr><td><a href="tcontrol.htm#textsize" target=_top>TextSize</a></td><td>property TextSize: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_textsize" target=_top>RE_TextSize</a></td><td>property RE_TextSize[ Units: TRichTextSize ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_charfmtarea" target=_top>RE_CharFmtArea</a></td><td>property RE_CharFmtArea: TRichFmtArea;</td></tr>
<tr><td><a href="tcontrol.htm#re_charformat" target=_top>RE_CharFormat</a></td><td>property RE_CharFormat: TCharFormat;</td></tr>
<tr><td><a href="tcontrol.htm#re_font" target=_top>RE_Font</a></td><td>property RE_Font: PGraphicTool;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtbold" target=_top>RE_FmtBold</a></td><td>property RE_FmtBold: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtitalic" target=_top>RE_FmtItalic</a></td><td>property RE_FmtItalic: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtstrikeout" target=_top>RE_FmtStrikeout</a></td><td>property RE_FmtStrikeout: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtunderline" target=_top>RE_FmtUnderline</a></td><td>property RE_FmtUnderline: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtunderlinestyle" target=_top>RE_FmtUnderlineStyle</a></td><td>property RE_FmtUnderlineStyle: TRichUnderline;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtprotected" target=_top>RE_FmtProtected</a></td><td>property RE_FmtProtected: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtprotectedvalid" target=_top>RE_FmtProtectedValid</a></td><td>property RE_FmtProtectedValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmthidden" target=_top>RE_FmtHidden</a></td><td>property RE_FmtHidden: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmthiddenvalid" target=_top>RE_FmtHiddenValid</a></td><td>property RE_FmtHiddenValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtlink" target=_top>RE_FmtLink</a></td><td>property RE_FmtLink: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtfontsize" target=_top>RE_FmtFontSize</a></td><td>property RE_FmtFontSize: Integer index( 12 shl 16 ) or CFM_SIZE;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtfontsizevalid" target=_top>RE_FmtFontSizeValid</a></td><td>property RE_FmtFontSizeValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtautobackcolor" target=_top>RE_FmtAutoBackColor</a></td><td>property RE_FmtAutoBackColor: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtfontcolor" target=_top>RE_FmtFontColor</a></td><td>property RE_FmtFontColor: Integer index( 20 shl 16 ) or CFM_COLOR;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtfontcolorvalid" target=_top>RE_FmtFontColorValid</a></td><td>property RE_FmtFontColorValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtautocolor" target=_top>RE_FmtAutoColor</a></td><td>property RE_FmtAutoColor: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtbackcolor" target=_top>RE_FmtBackColor</a></td><td>property RE_FmtBackColor: Integer index(( 64 + 32 ) shl 16 ) or CFM_BACKCOLOR;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtfontoffset" target=_top>RE_FmtFontOffset</a></td><td>property RE_FmtFontOffset: Integer index( 16 shl 16 ) or CFM_OFFSET;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtfontoffsetvalid" target=_top>RE_FmtFontOffsetValid</a></td><td>property RE_FmtFontOffsetValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtfontcharset" target=_top>RE_FmtFontCharset</a></td><td>property RE_FmtFontCharset: Integer index( 25 shl 16 ) or CFM_CHARSET;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtfontcharsetvalid" target=_top>RE_FmtFontCharsetValid</a></td><td>property RE_FmtFontCharsetValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtfontname" target=_top>RE_FmtFontName</a></td><td>property RE_FmtFontName: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#re_fmtfontnamevalid" target=_top>RE_FmtFontNameValid</a></td><td>property RE_FmtFontNameValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_parafmt" target=_top>RE_ParaFmt</a></td><td>property RE_ParaFmt: TParaFormat;</td></tr>
<tr><td><a href="tcontrol.htm#re_textalign" target=_top>RE_TextAlign</a></td><td>property RE_TextAlign: TRichTextAlign;</td></tr>
<tr><td><a href="tcontrol.htm#re_textalignvalid" target=_top>RE_TextAlignValid</a></td><td>property RE_TextAlignValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_numbering" target=_top>RE_Numbering</a></td><td>property RE_Numbering: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_numstyle" target=_top>RE_NumStyle</a></td><td>property RE_NumStyle: TRichNumbering;</td></tr>
<tr><td><a href="tcontrol.htm#re_numstart" target=_top>RE_NumStart</a></td><td>property RE_NumStart: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_numbrackets" target=_top>RE_NumBrackets</a></td><td>property RE_NumBrackets: TRichNumBrackets;</td></tr>
<tr><td><a href="tcontrol.htm#re_numtab" target=_top>RE_NumTab</a></td><td>property RE_NumTab: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_numberingvalid" target=_top>RE_NumberingValid</a></td><td>property RE_NumberingValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_level" target=_top>RE_Level</a></td><td>property RE_Level: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_spacebefore" target=_top>RE_SpaceBefore</a></td><td>property RE_SpaceBefore: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_spacebeforevalid" target=_top>RE_SpaceBeforeValid</a></td><td>property RE_SpaceBeforeValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_spaceafter" target=_top>RE_SpaceAfter</a></td><td>property RE_SpaceAfter: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_spaceaftervalid" target=_top>RE_SpaceAfterValid</a></td><td>property RE_SpaceAfterValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_linespacing" target=_top>RE_LineSpacing</a></td><td>property RE_LineSpacing: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_spacingrule" target=_top>RE_SpacingRule</a></td><td>property RE_SpacingRule: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_linespacingvalid" target=_top>RE_LineSpacingValid</a></td><td>property RE_LineSpacingValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_indent" target=_top>RE_Indent</a></td><td>property RE_Indent: Integer index( 20 shl 16 ) or PFM_OFFSET;</td></tr>
<tr><td><a href="tcontrol.htm#re_indentvalid" target=_top>RE_IndentValid</a></td><td>property RE_IndentValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_startindent" target=_top>RE_StartIndent</a></td><td>property RE_StartIndent: Integer index( 12 shl 16 ) or PFM_STARTINDENT;</td></tr>
<tr><td><a href="tcontrol.htm#re_startindentvalid" target=_top>RE_StartIndentValid</a></td><td>property RE_StartIndentValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_rightindent" target=_top>RE_RightIndent</a></td><td>property RE_RightIndent: Integer index( 16 shl 16 ) or PFM_RIGHTINDENT;</td></tr>
<tr><td><a href="tcontrol.htm#re_rightindentvalid" target=_top>RE_RightIndentValid</a></td><td>property RE_RightIndentValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_tabcount" target=_top>RE_TabCount</a></td><td>property RE_TabCount: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_tabs" target=_top>RE_Tabs</a></td><td>property RE_Tabs[ Idx: Integer ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_tabsvalid" target=_top>RE_TabsValid</a></td><td>property RE_TabsValid: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_autokeyboard" target=_top>RE_AutoKeyboard</a></td><td>property RE_AutoKeyboard: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_autofont" target=_top>RE_AutoFont</a></td><td>property RE_AutoFont: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_autofontsizeadjust" target=_top>RE_AutoFontSizeAdjust</a></td><td>property RE_AutoFontSizeAdjust: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_dualfont" target=_top>RE_DualFont</a></td><td>property RE_DualFont: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_uifonts" target=_top>RE_UIFonts</a></td><td>property RE_UIFonts: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_imecancelcomplete" target=_top>RE_IMECancelComplete</a></td><td>property RE_IMECancelComplete: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_imealwayssendnotify" target=_top>RE_IMEAlwaysSendNotify</a></td><td>property RE_IMEAlwaysSendNotify: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_overwritemode" target=_top>RE_OverwriteMode</a></td><td>property RE_OverwriteMode: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_disableoverwritechange" target=_top>RE_DisableOverwriteChange</a></td><td>property RE_DisableOverwriteChange: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_text" target=_top>RE_Text</a></td><td>property RE_Text[ Format: TRETextFormat; SelectionOnly: Boolean ]: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#re_error" target=_top>RE_Error</a></td><td>property RE_Error: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#re_autourldetect" target=_top>RE_AutoURLDetect</a></td><td>property RE_AutoURLDetect: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_url" target=_top>RE_URL</a></td><td>property RE_URL: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#re_transparent" target=_top>RE_Transparent</a></td><td>property RE_Transparent: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#re_zoom" target=_top>RE_Zoom</a></td><td>property RE_Zoom: TSmallPoint;</td></tr>
</table>
</p>
<a name="newrichedit1"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewRichEdit1</b></font>( AParent: <a href=#pcontrol>PControl</a>; Options: <a href=#teditoptions>TEditOptions</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Like <a href=#newrichedit>NewRichEdit</a>, but to work with older RichEdit control version 1.0
(window class 'RichEdit' forced to use instead of 'RichEdit20A', even
if library RICHED20.DLL found and loaded successfully). One more
difference - <a href=#oleinit>OleInit</a> is not called, so the most of OLE capabilities
of RichEdit could not working.
</p>
<a name="newlistbox"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewListbox</b></font>( AParent: <a href=#pcontrol>PControl</a>; Options: <a href=#tlistoptions>TListOptions</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates list box control. Following properties, methods and events are
special for Listbox:
<table border=0>
<tr><td><a href="tcontrol.htm#onmeasureitem" target=_top>OnMeasureItem</a></td><td>property OnMeasureItem: TOnMeasureItem;</td></tr>
<tr><td><a href="tcontrol.htm#onchange" target=_top>OnChange</a></td><td>property OnChange: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#onselchange" target=_top>OnSelChange</a></td><td>property OnSelChange: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#ondrawitem" target=_top>OnDrawItem</a></td><td>property OnDrawItem: TOnDrawItem;</td></tr>
<tr><td><a href="tcontrol.htm#beginupdate" target=_top>BeginUpdate</a></td><td>procedure BeginUpdate;</td></tr>
<tr><td><a href="tcontrol.htm#indexof" target=_top>IndexOf</a></td><td>function IndexOf( const S: KOLString ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#searchfor" target=_top>SearchFor</a></td><td>function SearchFor( const S: KOLString; StartAfter: Integer; Partial: Boolean ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#adddirlist" target=_top>AddDirList</a></td><td>procedure AddDirList( const Filemask: KOLString; Attrs: DWORD );</td></tr>
<tr><td><a href="tcontrol.htm#add" target=_top>Add</a></td><td>function Add( const S: KOLString ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#insert" target=_top>Insert</a></td><td>function Insert( Idx: Integer; const S: KOLString ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#delete" target=_top>Delete</a></td><td>procedure Delete( Idx: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#lbitematpos" target=_top>LBItemAtPos</a></td><td>function LBItemAtPos( X, Y: Integer ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#sellength" target=_top>SelLength</a></td><td>property SelLength: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#curindex" target=_top>CurIndex</a></td><td>property CurIndex: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#count" target=_top>Count</a></td><td>property Count: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#items" target=_top>Items</a></td><td>property Items[ Idx: Integer ]: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#itemselected" target=_top>ItemSelected</a></td><td>property ItemSelected[ ItemIdx: Integer ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#itemdata" target=_top>ItemData</a></td><td>property ItemData[ Idx: Integer ]: DWORD;</td></tr>
<tr><td><a href="tcontrol.htm#lvitemheight" target=_top>LVItemHeight</a></td><td>property LVItemHeight: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lbtopindex" target=_top>LBTopIndex</a></td><td>property LBTopIndex: Integer;</td></tr>
</table>
</p>
<a name="newcombobox"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewCombobox</b></font>( AParent: <a href=#pcontrol>PControl</a>; Options: <a href=#tcombooptions>TComboOptions</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates new combo box control. Note, that it is not possible to align
combobox caLeft or caRight: this can cause infinite recursion in the
application.
<br>Following properties, methods and events are
special for Combobox:
<table border=0>
<tr><td><a href="tcontrol.htm#ondropdown" target=_top>OnDropDown</a></td><td>property OnDropDown: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#oncloseup" target=_top>OnCloseUp</a></td><td>property OnCloseUp: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#onmeasureitem" target=_top>OnMeasureItem</a></td><td>property OnMeasureItem: TOnMeasureItem;</td></tr>
<tr><td><a href="tcontrol.htm#onchange" target=_top>OnChange</a></td><td>property OnChange: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#onselchange" target=_top>OnSelChange</a></td><td>property OnSelChange: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#ondrawitem" target=_top>OnDrawItem</a></td><td>property OnDrawItem: TOnDrawItem;</td></tr>
<tr><td><a href="tcontrol.htm#adddirlist" target=_top>AddDirList</a></td><td>procedure AddDirList( const Filemask: KOLString; Attrs: DWORD );</td></tr>
<tr><td><a href="tcontrol.htm#add" target=_top>Add</a></td><td>function Add( const S: KOLString ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#insert" target=_top>Insert</a></td><td>function Insert( Idx: Integer; const S: KOLString ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#delete" target=_top>Delete</a></td><td>procedure Delete( Idx: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#curindex" target=_top>CurIndex</a></td><td>property CurIndex: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#count" target=_top>Count</a></td><td>property Count: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#items" target=_top>Items</a></td><td>property Items[ Idx: Integer ]: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#itemselected" target=_top>ItemSelected</a></td><td>property ItemSelected[ ItemIdx: Integer ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#itemdata" target=_top>ItemData</a></td><td>property ItemData[ Idx: Integer ]: DWORD;</td></tr>
<tr><td><a href="tcontrol.htm#droppedwidth" target=_top>DroppedWidth</a></td><td>property DroppedWidth: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#droppeddown" target=_top>DroppedDown</a></td><td>property DroppedDown: Boolean;</td></tr>
</table>
</p>
<a name="newprogressbar"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewProgressbar</b></font>( AParent: <a href=#pcontrol>PControl</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates progress bar control. Following properties are special for
progress bar:
<table border=0>
<tr><td><a href="tcontrol.htm#progress" target=_top>Progress</a></td><td>property Progress: Integer index(( PBM_SETPOS or $8000 ) shl 16 ) or PBM_GETPOS;</td></tr>
<tr><td><a href="tcontrol.htm#maxprogress" target=_top>MaxProgress</a></td><td>property MaxProgress: Integer index(( PBM_SETRANGE32 or $8000 ) shl 16 ) or PBM_GETRANGE;</td></tr>
<tr><td><a href="tcontrol.htm#progresscolor" target=_top>ProgressColor</a></td><td>property ProgressColor: TColor;</td></tr>
<tr><td><a href="tcontrol.htm#progressbkcolor" target=_top>ProgressBkColor</a></td><td>property ProgressBkColor: TColor;</td></tr>
</table>
</p>
<a name="newprogressbarex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewProgressbarEx</b></font>( AParent: <a href=#pcontrol>PControl</a>; Options: <a href=#tprogressbaroptions>TProgressbarOptions</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Can create progress bar with smooth style (progress is not segmented
onto bricks) or/and vertical progress bar - using additional parameter.
For list of properties, suitable for progress bars, see <a href=#newprogressbar>NewProgressbar</a>.
</p>
<a name="newlistview"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewListView</b></font>( AParent: <a href=#pcontrol>PControl</a>; Style: <a href=#tlistviewstyle>TListViewStyle</a>; Options: TListViewOptions; ImageListSmall, ImageListNormal, ImageListState: <a href=#pimagelist>PImageList</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates list view control. It is very powerful control, which can partially
compensate absence of grid controls (in lvsDetail view mode). Properties,
methods and events, special for list view control are:
<table border=0>
<tr><td><a href="tcontrol.htm#onmeasureitem" target=_top>OnMeasureItem</a></td><td>property OnMeasureItem: TOnMeasureItem;</td></tr>
<tr><td><a href="tcontrol.htm#onendeditlvitem" target=_top>OnEndEditLVItem</a></td><td>property OnEndEditLVItem: TOnEditLVItem;</td></tr>
<tr><td><a href="tcontrol.htm#onlvdelete" target=_top>OnLVDelete</a></td><td>property OnLVDelete: TOnDeleteLVItem;</td></tr>
<tr><td><a href="tcontrol.htm#ondeletelvitem" target=_top>OnDeleteLVItem</a></td><td>property OnDeleteLVItem: TOnDeleteLVItem;</td></tr>
<tr><td><a href="tcontrol.htm#ondeletealllvitems" target=_top>OnDeleteAllLVItems</a></td><td>property OnDeleteAllLVItems: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#onlvdata" target=_top>OnLVData</a></td><td>property OnLVData: TOnLVData;</td></tr>
<tr><td><a href="tcontrol.htm#oncomparelvitems" target=_top>OnCompareLVItems</a></td><td>property OnCompareLVItems: TOnCompareLVItems;</td></tr>
<tr><td><a href="tcontrol.htm#oncolumnclick" target=_top>OnColumnClick</a></td><td>property OnColumnClick: TOnLVColumnClick;</td></tr>
<tr><td><a href="tcontrol.htm#onlvstatechange" target=_top>OnLVStateChange</a></td><td>property OnLVStateChange: TOnLVStateChange;</td></tr>
<tr><td><a href="tcontrol.htm#ondrawitem" target=_top>OnDrawItem</a></td><td>property OnDrawItem: TOnDrawItem;</td></tr>
<tr><td><a href="tcontrol.htm#onlvcustomdraw" target=_top>OnLVCustomDraw</a></td><td>property OnLVCustomDraw: TOnLVCustomDraw;</td></tr>
<tr><td><a href="tcontrol.htm#beginupdate" target=_top>BeginUpdate</a></td><td>procedure BeginUpdate;</td></tr>
<tr><td><a href="tcontrol.htm#setunicode" target=_top>SetUnicode</a></td><td>function SetUnicode( Unicode: Boolean ): PControl;</td></tr>
<tr><td><a href="tcontrol.htm#lvcoladd" target=_top>LVColAdd</a></td><td>procedure LVColAdd( const aText: KOLString; aalign: TTextAlign; aWidth: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#lvcolinsert" target=_top>LVColInsert</a></td><td>procedure LVColInsert( ColIdx: Integer; const aText: KOLString; aAlign: TTextAlign; aWidth: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#lvcoldelete" target=_top>LVColDelete</a></td><td>procedure LVColDelete( ColIdx: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#lvnextitem" target=_top>LVNextItem</a></td><td>function LVNextItem( IdxPrev: Integer; Attrs: DWORD ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvnextselected" target=_top>LVNextSelected</a></td><td>function LVNextSelected( IdxPrev: Integer ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvadd" target=_top>LVAdd</a></td><td>function LVAdd( const aText: KOLString; ImgIdx: Integer; State: TListViewItemState; StateImgIdx, OverlayImgIdx: Integer; Data: DWORD ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvitemadd" target=_top>LVItemAdd</a></td><td>function LVItemAdd( const aText: KOLString ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvinsert" target=_top>LVInsert</a></td><td>function LVInsert( Idx: Integer; const aText: KOLString; ImgIdx: Integer; State: TListViewItemState; StateImgIdx, OverlayImgIdx: Integer; Data: DWORD ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lviteminsert" target=_top>LVItemInsert</a></td><td>function LVItemInsert( Idx: Integer; const aText: KOLString ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvdelete" target=_top>LVDelete</a></td><td>procedure LVDelete( Idx: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#lvsetitem" target=_top>LVSetItem</a></td><td>procedure LVSetItem( Idx, Col: Integer; const aText: KOLString; ImgIdx: Integer; State: TListViewItemState; StateImgIdx, OverlayImgIdx: Integer; Data: DWORD );</td></tr>
<tr><td><a href="tcontrol.htm#lvselectall" target=_top>LVSelectAll</a></td><td>procedure LVSelectAll;</td></tr>
<tr><td><a href="tcontrol.htm#lvitemrect" target=_top>LVItemRect</a></td><td>function LVItemRect( Idx: Integer; Part: TGetLVItemPart ): TRect;</td></tr>
<tr><td><a href="tcontrol.htm#lvsubitemrect" target=_top>LVSubItemRect</a></td><td>function LVSubItemRect( Idx, ColIdx: Integer ): TRect;</td></tr>
<tr><td><a href="tcontrol.htm#lvitematpos" target=_top>LVItemAtPos</a></td><td>function LVItemAtPos( X, Y: Integer ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvitematposex" target=_top>LVItemAtPosEx</a></td><td>function LVItemAtPosEx( X, Y: Integer; var Where: TWherePosLVItem ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvmakevisible" target=_top>LVMakeVisible</a></td><td>procedure LVMakeVisible( Item: Integer; PartiallyOK: Boolean );</td></tr>
<tr><td><a href="tcontrol.htm#lvedititemlabel" target=_top>LVEditItemLabel</a></td><td>procedure LVEditItemLabel( Idx: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#lvsort" target=_top>LVSort</a></td><td>procedure LVSort;</td></tr>
<tr><td><a href="tcontrol.htm#lvsortdata" target=_top>LVSortData</a></td><td>procedure LVSortData;</td></tr>
<tr><td><a href="tcontrol.htm#lvsortcolumn" target=_top>LVSortColumn</a></td><td>procedure LVSortColumn( Idx: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#sellength" target=_top>SelLength</a></td><td>property SelLength: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#count" target=_top>Count</a></td><td>property Count: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#itemselected" target=_top>ItemSelected</a></td><td>property ItemSelected[ ItemIdx: Integer ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#rightclick" target=_top>RightClick</a></td><td>property RightClick: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#imagelistsmall" target=_top>ImageListSmall</a></td><td>property ImageListSmall: PImageList;</td></tr>
<tr><td><a href="tcontrol.htm#imagelistnormal" target=_top>ImageListNormal</a></td><td>property ImageListNormal: PImageList;</td></tr>
<tr><td><a href="tcontrol.htm#imageliststate" target=_top>ImageListState</a></td><td>property ImageListState: PImageList;</td></tr>
<tr><td><a href="tcontrol.htm#lvstyle" target=_top>LVStyle</a></td><td>property LVStyle: TListViewStyle;</td></tr>
<tr><td><a href="tcontrol.htm#lvoptions" target=_top>LVOptions</a></td><td>property LVOptions: TListViewOptions;</td></tr>
<tr><td><a href="tcontrol.htm#lvtextcolor" target=_top>LVTextColor</a></td><td>property LVTextColor: TColor;</td></tr>
<tr><td><a href="tcontrol.htm#lvtextbkcolor" target=_top>LVTextBkColor</a></td><td>property LVTextBkColor: TColor;</td></tr>
<tr><td><a href="tcontrol.htm#lvbkcolor" target=_top>LVBkColor</a></td><td>property LVBkColor: TColor;</td></tr>
<tr><td><a href="tcontrol.htm#lvcolcount" target=_top>LVColCount</a></td><td>property LVColCount: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvcolwidth" target=_top>LVColWidth</a></td><td>property LVColWidth[ Item: Integer ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvcoltext" target=_top>LVColText</a></td><td>property LVColText[ Idx: Integer ]: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#lvcolalign" target=_top>LVColAlign</a></td><td>property LVColAlign[ Idx: Integer ]: TTextAlign;</td></tr>
<tr><td><a href="tcontrol.htm#lvcolimage" target=_top>LVColImage</a></td><td>property LVColImage[ Idx: Integer ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvcolorder" target=_top>LVColOrder</a></td><td>property LVColOrder[ Idx: Integer ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvcount" target=_top>LVCount</a></td><td>property LVCount: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvcuritem" target=_top>LVCurItem</a></td><td>property LVCurItem: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvfocusitem" target=_top>LVFocusItem</a></td><td>property LVFocusItem: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvitemstate" target=_top>LVItemState</a></td><td>property LVItemState[ Idx: Integer ]: TListViewItemState;</td></tr>
<tr><td><a href="tcontrol.htm#lvitemstateimgidx" target=_top>LVItemStateImgIdx</a></td><td>property LVItemStateImgIdx[ Idx: Integer ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvitemoverlayimgidx" target=_top>LVItemOverlayImgIdx</a></td><td>property LVItemOverlayImgIdx[ Idx: Integer ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvitemdata" target=_top>LVItemData</a></td><td>property LVItemData[ Idx: Integer ]: DWORD;</td></tr>
<tr><td><a href="tcontrol.htm#lvselcount" target=_top>LVSelCount</a></td><td>property LVSelCount: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvitemimageindex" target=_top>LVItemImageIndex</a></td><td>property LVItemImageIndex[ Idx: Integer ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvitems" target=_top>LVItems</a></td><td>property LVItems[ Idx, Col: Integer ]: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#lvitempos" target=_top>LVItemPos</a></td><td>property LVItemPos[ Idx: Integer ]: TPoint;</td></tr>
<tr><td><a href="tcontrol.htm#lvtopitem" target=_top>LVTopItem</a></td><td>property LVTopItem: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvperpage" target=_top>LVPerPage</a></td><td>property LVPerPage: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#lvitemheight" target=_top>LVItemHeight</a></td><td>property LVItemHeight: Integer;</td></tr>
</table>
</p>
<a name="newtreeview"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewTreeView</b></font>( AParent: <a href=#pcontrol>PControl</a>; Options: <a href=#ttreeviewoptions>TTreeViewOptions</a>; ImgListNormal, ImgListState: <a href=#pimagelist>PImageList</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates tree view control. See tree view methods and properties:
<table border=0>
<tr><td><a href="tcontrol.htm#onselchange" target=_top>OnSelChange</a></td><td>property OnSelChange: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#ontvbegindrag" target=_top>OnTVBeginDrag</a></td><td>property OnTVBeginDrag: TOnTVBeginDrag;</td></tr>
<tr><td><a href="tcontrol.htm#ontvbeginedit" target=_top>OnTVBeginEdit</a></td><td>property OnTVBeginEdit: TOnTVBeginEdit;</td></tr>
<tr><td><a href="tcontrol.htm#ontvendedit" target=_top>OnTVEndEdit</a></td><td>property OnTVEndEdit: TOnTVEndEdit;</td></tr>
<tr><td><a href="tcontrol.htm#ontvexpanding" target=_top>OnTVExpanding</a></td><td>property OnTVExpanding: TOnTVExpanding;</td></tr>
<tr><td><a href="tcontrol.htm#ontvexpanded" target=_top>OnTVExpanded</a></td><td>property OnTVExpanded: TOnTVExpanded;</td></tr>
<tr><td><a href="tcontrol.htm#ontvdelete" target=_top>OnTVDelete</a></td><td>property OnTVDelete: TOnTVDelete;</td></tr>
<tr><td><a href="tcontrol.htm#ontvselchanging" target=_top>OnTVSelChanging</a></td><td>property OnTVSelChanging: TOnTVSelChanging;</td></tr>
<tr><td><a href="tcontrol.htm#beginupdate" target=_top>BeginUpdate</a></td><td>procedure BeginUpdate;</td></tr>
<tr><td><a href="tcontrol.htm#setunicode" target=_top>SetUnicode</a></td><td>function SetUnicode( Unicode: Boolean ): PControl;</td></tr>
<tr><td><a href="tcontrol.htm#tvinsert" target=_top>TVInsert</a></td><td>function TVInsert( nParent, nAfter: THandle; const Txt: KOLString ): THandle;</td></tr>
<tr><td><a href="tcontrol.htm#tvdelete" target=_top>TVDelete</a></td><td>procedure TVDelete( Item: THandle );</td></tr>
<tr><td><a href="tcontrol.htm#tvitempath" target=_top>TVItemPath</a></td><td>function TVItemPath( Item: THandle; Delimiter: KOLChar ): KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#tvitematpos" target=_top>TVItemAtPos</a></td><td>function TVItemAtPos( x, y: Integer; var Where: DWORD ): THandle;</td></tr>
<tr><td><a href="tcontrol.htm#tvexpand" target=_top>TVExpand</a></td><td>procedure TVExpand( Item: THandle; Flags: DWORD );</td></tr>
<tr><td><a href="tcontrol.htm#tvsort" target=_top>TVSort</a></td><td>procedure TVSort( N: THandle );</td></tr>
<tr><td><a href="tcontrol.htm#tvedititem" target=_top>TVEditItem</a></td><td>procedure TVEditItem( Item: THandle );</td></tr>
<tr><td><a href="tcontrol.htm#tvstopedit" target=_top>TVStopEdit</a></td><td>procedure TVStopEdit( Cancel: Boolean );</td></tr>
<tr><td><a href="tcontrol.htm#count" target=_top>Count</a></td><td>property Count: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#imagelistnormal" target=_top>ImageListNormal</a></td><td>property ImageListNormal: PImageList;</td></tr>
<tr><td><a href="tcontrol.htm#imageliststate" target=_top>ImageListState</a></td><td>property ImageListState: PImageList;</td></tr>
<tr><td><a href="tcontrol.htm#tvselected" target=_top>TVSelected</a></td><td>property TVSelected: THandle;</td></tr>
<tr><td><a href="tcontrol.htm#tvdrophilighted" target=_top>TVDropHilighted</a></td><td>property TVDropHilighted: THandle;</td></tr>
<tr><td><a href="tcontrol.htm#tvfirstvisible" target=_top>TVFirstVisible</a></td><td>property TVFirstVisible: THandle;</td></tr>
<tr><td><a href="tcontrol.htm#tvindent" target=_top>TVIndent</a></td><td>property TVIndent: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tvvisiblecount" target=_top>TVVisibleCount</a></td><td>property TVVisibleCount: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tvroot" target=_top>TVRoot</a></td><td>property TVRoot: THandle;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemchild" target=_top>TVItemChild</a></td><td>property TVItemChild[ Item: THandle ]: THandle;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemhaschildren" target=_top>TVItemHasChildren</a></td><td>property TVItemHasChildren[ Item: THandle ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemchildcount" target=_top>TVItemChildCount</a></td><td>property TVItemChildCount[ Item: THandle ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemnext" target=_top>TVItemNext</a></td><td>property TVItemNext[ Item: THandle ]: THandle;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemprevious" target=_top>TVItemPrevious</a></td><td>property TVItemPrevious[ Item: THandle ]: THandle;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemnextvisible" target=_top>TVItemNextVisible</a></td><td>property TVItemNextVisible[ Item: THandle ]: THandle;</td></tr>
<tr><td><a href="tcontrol.htm#tvitempreviousvisible" target=_top>TVItemPreviousVisible</a></td><td>property TVItemPreviousVisible[ Item: THandle ]: THandle;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemparent" target=_top>TVItemParent</a></td><td>property TVItemParent[ Item: THandle ]: THandle;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemtext" target=_top>TVItemText</a></td><td>property TVItemText[ Item: THandle ]: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemrect" target=_top>TVItemRect</a></td><td>property TVItemRect[ Item: THandle; TextOnly: Boolean ]: TRect;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemvisible" target=_top>TVItemVisible</a></td><td>property TVItemVisible[ Item: THandle ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tvrightclickselect" target=_top>TVRightClickSelect</a></td><td>property TVRightClickSelect: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tvediting" target=_top>TVEditing</a></td><td>property TVEditing: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tvitembold" target=_top>TVItemBold</a></td><td>property TVItemBold[ Item: THandle ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemcut" target=_top>TVItemCut</a></td><td>property TVItemCut[ Item: THandle ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemdrophighlighted" target=_top>TVItemDropHighlighted</a></td><td>property TVItemDropHighlighted[ Item: THandle ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemexpanded" target=_top>TVItemExpanded</a></td><td>property TVItemExpanded[ Item: THandle ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemexpandedonce" target=_top>TVItemExpandedOnce</a></td><td>property TVItemExpandedOnce[ Item: THandle ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemselected" target=_top>TVItemSelected</a></td><td>property TVItemSelected[ Item: THandle ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemimage" target=_top>TVItemImage</a></td><td>property TVItemImage[ Item: THandle ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemselimg" target=_top>TVItemSelImg</a></td><td>property TVItemSelImg[ Item: THandle ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemoverlay" target=_top>TVItemOverlay</a></td><td>property TVItemOverlay[ Item: THandle ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemstateimg" target=_top>TVItemStateImg</a></td><td>property TVItemStateImg[ Item: THandle ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tvitemdata" target=_top>TVItemData</a></td><td>property TVItemData[ Item: THandle ]: Pointer;</td></tr>
</table>
</p>
<a name="newtabcontrol"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewTabControl</b></font>( AParent: <a href=#pcontrol>PControl</a>; <b>const</b> Tabs: <b>array</b> <b>of</b> PKOLChar; Options: <a href=#ttabcontroloptions>TTabControlOptions</a>; ImgList: <a href=#pimagelist>PImageList</a>; ImgList1stIdx: <b>Integer</b> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates new tab control (like notebook). To place child control on a certain
page of TabControl, use property Pages[ Idx ], for example:
<p align=left><font face="Courier" color="008080"><b><pre>
 Label1 := <a href="kol_pas.htm#newlabel target="_top""><font color="008080">NewLabel</font></a>( TabControl1.Pages[ 0 ], <font color="A08020">'Label1'</font> );
</pre></b></font></p>
 &nbsp;&nbsp;&nbsp;
To determine number of pages at run time, use property
<a href="tcontrol.htm#Count" target=_top> Count </a>
;
<br> to determine which page is currently selected (or to change
selection), use property
<a href="tcontrol.htm#CurIndex" target=_top> CurIndex </a>
;
<br> to feedback to switch between tabs assign your handler to OnSelChange
event;
<br>Note, that by default, tab control is created with a border lowered to
tab control's parent. To remove it, you can apply WS_EX_TRANSPARENT extended
style (see <a href=tcontrol.htm#exstyle>TControl.ExStyle</a> property), but painting of some child controls
can be strange a bit in this case (no border drawing for edit controls was
found, but not always...). You can also apply style WS_THICKFRAME (<a href=tcontrol.htm#style>TControl.Style</a>
property) to make the border raised.
<br> Other methods and properties, suitable for tab control, are:
<table border=0>
<tr><td><a href="tcontrol.htm#onchange" target=_top>OnChange</a></td><td>property OnChange: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#indexof" target=_top>IndexOf</a></td><td>function IndexOf( const S: KOLString ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#searchfor" target=_top>SearchFor</a></td><td>function SearchFor( const S: KOLString; StartAfter: Integer; Partial: Boolean ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#setunicode" target=_top>SetUnicode</a></td><td>function SetUnicode( Unicode: Boolean ): PControl;</td></tr>
<tr><td><a href="tcontrol.htm#tc_insert" target=_top>TC_Insert</a></td><td>function TC_Insert( Idx: Integer; const TabText: KOLString; TabImgIdx: Integer ): PControl;</td></tr>
<tr><td><a href="tcontrol.htm#tc_delete" target=_top>TC_Delete</a></td><td>procedure TC_Delete( Idx: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#tc_insertcontrol" target=_top>TC_InsertControl</a></td><td>procedure TC_InsertControl( Idx: Integer; const TabText: KOLString; TabImgIdx: Integer; Page: PControl );</td></tr>
<tr><td><a href="tcontrol.htm#tc_remove" target=_top>TC_Remove</a></td><td>function TC_Remove( Idx: Integer ): PControl;</td></tr>
<tr><td><a href="tcontrol.htm#tc_setpadding" target=_top>TC_SetPadding</a></td><td>procedure TC_SetPadding( cx, cy: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#tc_tabatpos" target=_top>TC_TabAtPos</a></td><td>function TC_TabAtPos( x, y: Integer ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tc_displayrect" target=_top>TC_DisplayRect</a></td><td>function TC_DisplayRect: TRect;</td></tr>
<tr><td><a href="tcontrol.htm#tc_indexof" target=_top>TC_IndexOf</a></td><td>function TC_IndexOf( const S: KOLString ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tc_searchfor" target=_top>TC_SearchFor</a></td><td>function TC_SearchFor( const S: KOLString; StartAfter: Integer; Partial: Boolean ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#imagelistnormal" target=_top>ImageListNormal</a></td><td>property ImageListNormal: PImageList;</td></tr>
<tr><td><a href="tcontrol.htm#pages" target=_top>Pages</a></td><td>property Pages[ Idx: Integer ]: PControl;</td></tr>
<tr><td><a href="tcontrol.htm#tc_pages" target=_top>TC_Pages</a></td><td>property TC_Pages[ Idx: Integer ]: PControl;</td></tr>
<tr><td><a href="tcontrol.htm#tc_items" target=_top>TC_Items</a></td><td>property TC_Items[ Idx: Integer ]: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#tc_images" target=_top>TC_Images</a></td><td>property TC_Images[ Idx: Integer ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tc_itemrect" target=_top>TC_ItemRect</a></td><td>property TC_ItemRect[ Idx: Integer ]: TRect;</td></tr>
</table>
</p>
<a name="newtabempty"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewTabEmpty</b></font>( AParent: <a href=#pcontrol>PControl</a>; Options: <a href=#ttabcontroloptions>TTabControlOptions</a>; ImgList: <a href=#pimagelist>PImageList</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates new empty tab control for using metods TC_Insert (to create Pages as Panel),
or TC_InsertControl (if you want using your custom Pages).
</p>
<a name="newtoolbar"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewToolbar</b></font>( AParent: <a href=#pcontrol>PControl</a>; Align: <a href=#tcontrolalign>TControlAlign</a>; Options: <a href=#ttoolbaroptions>TToolbarOptions</a>; Bitmap: HBitmap; <b>const</b> Buttons: <b>array</b> <b>of</b> PKOLChar; <b>const</b> BtnImgIdxArray: <b>array</b> <b>of</b> <b>Integer</b> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates toolbar control. Bitmap (if present) must contain images for all buttons
excluding separators (defined by string '-' in Buttons array) and system images,
otherwise last buttons will no have images at all. Image width for every button
is assumed to be equal to Bitmap height (if last of &quot;squares&quot; has
insufficient width, it will not be used). To define fixed buttons, use
characters '+' or '-' as a prefix for button string (even empty). To
create groups of (radio-)buttons, use also '!' follow '+' or '-'. (These rules
are similar used in menu creation). To define drop down button, use (as
first) prefix '^'. (Do not forget to set
<a href="tcontrol.htm#OnTBDropDown" target=_top> OnTBDropDown </a>
event for this
case). If You want to assign images to buttons not in the same order
how these are placed in Bitmap (or You use system bitmap), define for every
button (in BtnImgIdxArray array) indexes for every button (excluding
separator buttons). Otherwise, it is possible to define index only for first
button (e.g., [0]). It is also possible to change TBImages[ ] property
for such purpose, or do the same in method TBSetBtnImgIdx).
<br>
Following properties, methods and event are specially designed to work with
toolbar control:
<table border=0>
<tr><td><a href="tcontrol.htm#ondropdown" target=_top>OnDropDown</a></td><td>property OnDropDown: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#onclick" target=_top>OnClick</a></td><td>property OnClick: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#ontbdropdown" target=_top>OnTBDropDown</a></td><td>property OnTBDropDown: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#ontbclick" target=_top>OnTBClick</a></td><td>property OnTBClick: TOnEvent;</td></tr>
<tr><td><a href="tcontrol.htm#ontbcustomdraw" target=_top>OnTBCustomDraw</a></td><td>property OnTBCustomDraw: TOnTBCustomDraw;</td></tr>
<tr><td><a href="tcontrol.htm#tbaddbitmap" target=_top>TBAddBitmap</a></td><td>procedure TBAddBitmap( Bitmap: HBitmap );</td></tr>
<tr><td><a href="tcontrol.htm#tbaddbuttons" target=_top>TBAddButtons</a></td><td>function TBAddButtons( const Buttons: array of PKOLChar; const BtnImgIdxArray: array of Integer ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tbinsertbuttons" target=_top>TBInsertButtons</a></td><td>function TBInsertButtons( BeforeIdx: Integer; Buttons: array of PKOLChar; BtnImgIdxArray: array of Integer ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tbdeletebutton" target=_top>TBDeleteButton</a></td><td>procedure TBDeleteButton( BtnID: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#tbdeletebtnbyidx" target=_top>TBDeleteBtnByIdx</a></td><td>procedure TBDeleteBtnByIdx( Idx: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#tbclear" target=_top>TBClear</a></td><td>procedure TBClear;</td></tr>
<tr><td><a href="tcontrol.htm#tbassignevents" target=_top>TBAssignEvents</a></td><td>procedure TBAssignEvents( BtnID: Integer; Events: array of TOnToolbarButtonClick );</td></tr>
<tr><td><a href="tcontrol.htm#tbresetimgidx" target=_top>TBResetImgIdx</a></td><td>procedure TBResetImgIdx( BtnID, BtnCount: Integer );</td></tr>
<tr><td><a href="tcontrol.htm#tbitem2index" target=_top>TBItem2Index</a></td><td>function TBItem2Index( BtnID: Integer ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tbindex2item" target=_top>TBIndex2Item</a></td><td>function TBIndex2Item( Idx: Integer ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tbconvertidxarray2id" target=_top>TBConvertIdxArray2ID</a></td><td>procedure TBConvertIdxArray2ID( const IdxVars: array of PDWORD );</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttonseparator" target=_top>TBButtonSeparator</a></td><td>function TBButtonSeparator( BtnID: Integer ): Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttonatpos" target=_top>TBButtonAtPos</a></td><td>function TBButtonAtPos( X, Y: Integer ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tbbtnidxatpos" target=_top>TBBtnIdxAtPos</a></td><td>function TBBtnIdxAtPos( X, Y: Integer ): Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tbmovebtn" target=_top>TBMoveBtn</a></td><td>function TBMoveBtn( FromIdx, ToIdx: Integer ): Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tbsettooltips" target=_top>TBSetTooltips</a></td><td>procedure TBSetTooltips( BtnID1st: Integer; const Tooltips: array of PKOLChar );</td></tr>
<tr><td><a href="tcontrol.htm#curindex" target=_top>CurIndex</a></td><td>property CurIndex: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#count" target=_top>Count</a></td><td>property Count: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#rightclick" target=_top>RightClick</a></td><td>property RightClick: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#curitem" target=_top>CurItem</a></td><td>property CurItem: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttoncount" target=_top>TBButtonCount</a></td><td>property TBButtonCount: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tbbtnimgwidth" target=_top>TBBtnImgWidth</a></td><td>property TBBtnImgWidth: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttonenabled" target=_top>TBButtonEnabled</a></td><td>property TBButtonEnabled[ BtnID: Integer ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttonvisible" target=_top>TBButtonVisible</a></td><td>property TBButtonVisible[ BtnID: Integer ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttonchecked" target=_top>TBButtonChecked</a></td><td>property TBButtonChecked[ BtnID: Integer ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttonmarked" target=_top>TBButtonMarked</a></td><td>property TBButtonMarked[ BtnID: Integer ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttonpressed" target=_top>TBButtonPressed</a></td><td>property TBButtonPressed[ BtnID: Integer ]: Boolean;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttontext" target=_top>TBButtonText</a></td><td>property TBButtonText[ BtnID: Integer ]: KOLString;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttonimage" target=_top>TBButtonImage</a></td><td>property TBButtonImage[ BtnID: Integer ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttonrect" target=_top>TBButtonRect</a></td><td>property TBButtonRect[ BtnID: Integer ]: TRect;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttonwidth" target=_top>TBButtonWidth</a></td><td>property TBButtonWidth[ BtnID: Integer ]: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttonlparam" target=_top>TBButtonLParam</a></td><td>property TBButtonLParam[ const Idx: Integer ]: DWORD;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttonsminwidth" target=_top>TBButtonsMinWidth</a></td><td>property TBButtonsMinWidth: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tbbuttonsmaxwidth" target=_top>TBButtonsMaxWidth</a></td><td>property TBButtonsMaxWidth: Integer;</td></tr>
<tr><td><a href="tcontrol.htm#tbrows" target=_top>TBRows</a></td><td>property TBRows: Integer;</td></tr>
</table>
</p>
<a name="newdatetimepicker"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewDateTimePicker</b></font>( AParent: <a href=#pcontrol>PControl</a>; Options: <a href=#tdatetimepickeroptions>TDateTimePickerOptions</a> ): <a href=#pcontrol>PControl</a>;</font>
<br>
 <a name="control">
Creates date and time picker common control.
</p>
<a name="newimagelist"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewImageList</b></font>( AOwner: <a href=#pcontrol>PControl</a> ): <a href=#pimagelist>PImageList</a>;</font>
<br>
Constructor of <a href=#timagelist>TImageList</a> object. Unlike other non-visual objects, image list
can be parented by <a href=#tcontrol>TControl</a> object (but this does not *must*), and in that
case it is destroyed automatically when its parent control is destroyed.
Every control can have several <a href=#timagelist>TImageList</a> objects, linked to a simple list.
But if any <a href=#timagelist>TImageList</a> object is destroyed, all following ones are destroyed
too (at least, now I implemented it so).
</p>
<a name="newtimer"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewTimer</b></font>( Interval: <b>Integer</b> ): PTimer;</font>
<br>
Constructs initially disabled timer with interval 1000 (1 second).
</p>
<a name="newmmtimer"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewMMTimer</b></font>( Interval: <b>Integer</b> ): PMMTimer;</font>
<br>
Creates multimedia timer object. Initially, it has Resolution = 0,
Periodic = TRUE and Enabled = FALSE. Do not forget also to assign your
event handler to OnTimer to do something on timer shot.
</p>
<a name="tontrayiconmouse"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnTrayIconMouse</b></font> = <b>procedure</b>( Sender: <a href=#pobj>PObj</a>; Message: <b>Word</b> ) <b>of</b> <b>object</b>;</font>
<br>
Event type to be called when <a href=#applet>Applet</a> receives a message from an icon,
added to the taskbar tray.
</p>
<a name="newtrayicon"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewTrayIcon</b></font>( Wnd: <a href=#pcontrol>PControl</a>; Icon: HIcon ): PTrayIcon;</font>
<br>
Constructor of <a href=#ttrayicon>TTrayIcon</a> object. Pass main form or applet as Wnd
parameter.
</p>
<a name="tonanotherinstance"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnAnotherInstance</b></font> = <b>procedure</b>( <b>const</b> CmdLine: KOLString ) <b>of</b> <b>object</b>;</font>
<br>
Event type to use in <a href=#justonenotify>JustOneNotify</a> function.
</p>
<a name="justone"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>JustOne</b></font>( Wnd: <a href=#pcontrol>PControl</a>; <b>const</b> Identifier: AnsiString ): <b>Boolean</b>;</font>
<br>
Returns True, if this is a first instance. For all other instances
(application is already running), False is returned.
</p>
<a name="justonenotify"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>JustOneNotify</b></font>( Wnd: <a href=#pcontrol>PControl</a>; <b>const</b> Identifier: KOLString; <b>const</b> aOnAnotherInstance: <a href=#tonanotherinstance>TOnAnotherInstance</a> ): <b>Boolean</b>;</font>
<br>
Returns True, if this is a first instance. For all other instances
(application is already running), False is returned. If handler
aOnAnotherInstance passed, it is called (in first instance) every time
when another instance of an application is started, receiving command
line used to run it.
</p>
<a name="msgbox"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>MsgBox</b></font>( <b>const</b> S: KOLString; Flags: <b>DWORD</b> ): <b>DWORD</b>;</font>
<br>
Displays message box with the same title as <a href=kol_pas.htm#applet#caption>Applet.Caption</a>. If applet
is not running, and <a href=#applet>Applet</a> global variable is not assigned, caption
'Error' is displayed (but actually this is not an error - the system
does so, if nil is passed as a title).
<br>&nbsp;&nbsp;&nbsp;
Returns ID_... result (correspondently to flags passed (MB_OK, MBYESNO,
etc. -&gt; ID_OK, ID_YES, ID_NO, etc.)
</p>
<a name="msgok"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>MsgOK</b></font>( <b>const</b> S: KOLString );</font>
<br>
Displays message box with the same title as <a href=kol_pas.htm#applet#caption>Applet.Caption</a> (or 'Error',
if <a href=#applet>Applet</a> is not running).
</p>
<a name="showmsg"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ShowMsg</b></font>( <b>const</b> S: KOLString; Flags: <b>DWORD</b> ): <b>DWORD</b>;</font>
<br>
Displays message box like <a href=#msgbox>MsgBox</a>, but uses <a href=kol_pas.htm#applet#handle>Applet.Handle</a> as a parent
(so the message has no button on a task bar).
</p>
<a name="showmessage"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>ShowMessage</b></font>( <b>const</b> S: KOLString );</font>
<br>
Like <a href=#showmsg>ShowMsg</a>, but has only styles MB_OK and MB_SETFOREGROUND.
</p>
<a name="speakerbeep"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>SpeakerBeep</b></font>( Freq: <b>Word</b>; Duration: <b>DWORD</b> );</font>
<br>
On Windows NT, calls Windows.Beep. On Windows 9x, produces beep on speaker
of desired frequency during given duration time (in milliseconds).
</p>
<a name="syserrormessage"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>SysErrorMessage</b></font>( ErrorCode: <b>Integer</b> ): KOLString;</font>
<br>
Creates and returns a string containing formatted system error message.
It is possible then to display this message or write it to a log
file, e.g.:
<p align=left><font face="Courier" color="008080"><b><pre>
  <a href="kol_pas.htm#showmsg target="_top""><font color="008080">ShowMsg</font></a>( SysErrorMessage( GetLastError ) );
</pre></b></font></p>
<a name="64-bit integer numbers"></a><font color=#FF8040><h1>64-bit integer numbers</h1></font>

</p>
<a name="i64"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>I64</b></font> = <b>record</b></font>
<br>
64 bit integer record. Use it and correspondent functions below in KOL
projects to avoid dependancy from Delphi version (earlier versions of
Delphi had no Int64 type).
<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">Lo, Hi: <b>DWORD</b>;</font>
    </td>
    <td valign="top">
    </td>
  </tr>
</table>
<font face="Courier" color="#800080"><b>end</b>;</font>
</p>
<a name="pi64"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>PI64</b></font> = ^ <a href=#i64>I64</a>;</font>
<br>
</p>
<a name="makeint64"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>MakeInt64</b></font>( Lo, Hi: <b>DWORD</b> ): <a href=#i64>I64</a>;</font>
<br>
</p>
<a name="int2int64"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Int2Int64</b></font>( X: <b>Integer</b> ): <a href=#i64>I64</a>;</font>
<br>
</p>
<a name="incint64"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>IncInt64</b></font>( <b>var</b> <a href=#i64>I64</a>: <a href=#i64>I64</a>; Delta: <b>Integer</b> );</font>
<br>
<a href=#i64>I64</a> := <a href=#i64>I64</a> + Delta;
</p>
<a name="decint64"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>DecInt64</b></font>( <b>var</b> <a href=#i64>I64</a>: <a href=#i64>I64</a>; Delta: <b>Integer</b> );</font>
<br>
<a href=#i64>I64</a> := <a href=#i64>I64</a> - Delta;
</p>
<a name="add64"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Add64</b></font>( <b>const</b> X, Y: <a href=#i64>I64</a> ): <a href=#i64>I64</a>;</font>
<br>
Result := X + Y;
</p>
<a name="sub64"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Sub64</b></font>( <b>const</b> X, Y: <a href=#i64>I64</a> ): <a href=#i64>I64</a>;</font>
<br>
Result := X - Y;
</p>
<a name="neg64"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Neg64</b></font>( <b>const</b> X: <a href=#i64>I64</a> ): <a href=#i64>I64</a>;</font>
<br>
Result := -X;
</p>
<a name="mul64i"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Mul64i</b></font>( <b>const</b> X: <a href=#i64>I64</a>; Mul: <b>Integer</b> ): <a href=#i64>I64</a>;</font>
<br>
Result := X * Mul;
</p>
<a name="div64i"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Div64i</b></font>( <b>const</b> X: <a href=#i64>I64</a>; D: <b>Integer</b> ): <a href=#i64>I64</a>;</font>
<br>
Result := X div D;
</p>
<a name="mod64i"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Mod64i</b></font>( <b>const</b> X: <a href=#i64>I64</a>; D: <b>Integer</b> ): <b>Integer</b>;</font>
<br>
Result := X mod D;
</p>
<a name="sgn64"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Sgn64</b></font>( <b>const</b> X: <a href=#i64>I64</a> ): <b>Integer</b>;</font>
<br>
Result := sign( X ); i.e.:
<br>
if X &lt; 0 then -1
<br>
if X = 0 then 0
<br>
if X &gt; 0 then 1
</p>
<a name="cmp64"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Cmp64</b></font>( <b>const</b> X, Y: <a href=#i64>I64</a> ): <b>Integer</b>;</font>
<br>
Result := sign( X - Y ); i.e.
<br>
if X &lt; Y then -1
<br>
if X = Y then 0
<br>
if X &gt; Y then 1
</p>
<a name="int64_2str"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Int64_2Str</b></font>( X: <a href=#i64>I64</a> ): AnsiString;</font>
<br>
</p>
<a name="int64_2hex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Int64_2Hex</b></font>( X: <a href=#i64>I64</a>; MinDigits: <b>Integer</b> ): AnsiString;</font>
<br>
</p>
<a name="str2int64"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Str2Int64</b></font>( <b>const</b> S: AnsiString ): <a href=#i64>I64</a>;</font>
<br>
</p>
<a name="int64_2double"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Int64_2Double</b></font>( <b>const</b> X: <a href=#i64>I64</a> ): <b>Double</b>;</font>
<br>
</p>
<a name="double2int64"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Double2Int64</b></font>( D: <b>Double</b> ): <a href=#i64>I64</a>;</font>
<br>
<a name="Floating point numbers"></a><font color=#FF8040><h1>Floating point numbers</h1></font>

</p>
<a name="isnan"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>IsNan</b></font>( <b>const</b> AValue: <b>Double</b> ): <b>Boolean</b>;</font>
<br>
Checks if an argument passed is NAN.
</p>
<a name="isinfinity"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>IsInfinity</b></font>( <b>const</b> AValue: <b>Double</b> ): <b>Boolean</b>;</font>
<br>
Checks if an argument passed is Infinite.
</p>
<a name="intpower"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>IntPower</b></font>( Base: Extended; Exponent: <b>Integer</b> ): Extended;</font>
<br>
Result := Base ^ Exponent;
</p>
<a name="nextpowerof2"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NextPowerOf2</b></font>( n: <b>DWORD</b> ): <b>DWORD</b>;</font>
<br>
0-&gt;1, 1-&gt;1, 2-&gt;2, 3-&gt;4, 4-&gt;4, 5-&gt;8, ...
</p>
<a name="str2double"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Str2Double</b></font>( <b>const</b> S: AnsiString ): <b>Double</b>;</font>
<br>
</p>
<a name="str2extended"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Str2Extended</b></font>( <b>const</b> S: AnsiString ): Extended;</font>
<br>
</p>
<a name="double2str"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Double2Str</b></font>( D: <b>Double</b> ): AnsiString;</font>
<br>
</p>
<a name="extended2str"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Extended2Str</b></font>( E: Extended ): AnsiString;</font>
<br>
</p>
<a name="extended2strdigits"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Extended2StrDigits</b></font>( D: <b>Double</b>; n: <b>Integer</b> ): AnsiString;</font>
<br>
Converts floating point number to string, leaving exactly n digits
following floating point.
</p>
<a name="double2strex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Double2StrEx</b></font>( D: <b>Double</b> ): AnsiString;</font>
<br>
experimental, do not use
</p>
<a name="truncd"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>TruncD</b></font>( D: <b>Double</b> ): <b>Double</b>;</font>
<br>
Result := trunc( D ) as Double;
<hr>
<a name="Small bit arrays (max 32 bits in array)"></a><font color=#FF8040><h1>Small bit arrays (max 32 bits in array)</h1></font>

See also TBits object.
</p>
<a name="getbits"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetBits</b></font>( N: <b>DWORD</b>; first, last: <b>Byte</b> ): <b>DWord</b>;</font>
<br>
Retuns bits straing from &lt;first&gt; and to &lt;last&gt; inclusively.
</p>
<a name="getbitsl"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetBitsL</b></font>( N: <b>DWORD</b>; from, len: <b>Byte</b> ): <b>DWord</b>;</font>
<br>
Retuns len bits starting from index &lt;from&gt;.
<hr>
<a name="Arithmetics, geometry and other utility functions"></a><font color=#FF8040><h1>Arithmetics, geometry and other utility functions</h1></font>

See also units KolMath.pas, CplxMath.pas and Err.pas.
</p>
<a name="muldiv"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>MulDiv</b></font>( A, B, C: <b>Integer</b> ): <b>Integer</b>;</font>
<br>
Returns A * B div C. Small and fast.
</p>
<a name="tmethod"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TMethod</b></font> = <b>packed</b> <b>record</b></font>
<br>
Is defined here because using of VCL classes.pas unit is
not recommended in XCL. This record type is used often
to set/access event handlers, referring to a procedure
of object (usually to set such event to an ordinal
procedure setting Data field to nil.
<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">Code: <b>Pointer</b>;</font>
    </td>
    <td valign="top">
Pointer to method code.
</td></tr><tr><td width="32">&nbsp;</td>
<td colspan=2 valign=top>
If used to fake assigning to event handler of type 'procedure
of object' with ordinal procedure pointer, use symbol '@'
before method:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier"><b>
    Method.Code := @MyProcedure;
</b></font>
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">Data: <b>Pointer</b>;</font>
    </td>
    <td valign="top">
Pointer to object, owning the method.
</td></tr><tr><td width="32">&nbsp;</td>
<td colspan=2 valign=top>
To fake event of type 'procedure of object' with setting it to
ordinal procedure assign here NIL;
    </td>
  </tr>
</table>
When assigning TMethod record to event handler, typecast it with
desired event type, e.g.:
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font face="Courier"><b>
     SomeObject.OnSomeEvent := TOnSomeEvent( Method );
</b></font><br>
<font face="Courier" color="#800080"><b>end</b>;</font>
</p>
<a name="pmethod"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>PMethod</b></font> = ^ <a href=#tmethod>TMethod</a>;</font>
<br>
</p>
<a name="makemethod"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>MakeMethod</b></font>( Data, Code: <b>Pointer</b> ): <a href=#tmethod>TMethod</a>;</font>
<br>
Help function to construct <a href=#tmethod>TMethod</a> record. Can be useful to
assign regular type procedure/function as event handler for
event, defined as object method (do not forget, that in that
case it must have first dummy parameter to replace @Self,
passed in EAX to methods of object).
</p>
<a name="makerect"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>MakeRect</b></font>( Left, Top, Right, Bottom: <b>Integer</b> ): TRect; stdcall;</font>
<br>
Use it instead of VCL Rect function
</p>
<a name="rectsequal"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RectsEqual</b></font>( <b>const</b> R1, R2: TRect ): <b>Boolean</b>;</font>
<br>
Returns True if rectangles R1 and R2 have the same bounds
</p>
<a name="rectsintersected"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RectsIntersected</b></font>( <b>const</b> R1, R2: TRect ): <b>Boolean</b>;</font>
<br>
Returns TRUE if rectangles R1 and R2 have at least one common point.
Note, that right and bottom bounds of rectangles are not their part,
so, if such points are lying on that bounds, FALSE is returned.
</p>
<a name="pointinrect"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>PointInRect</b></font>( <b>const</b> P: TPoint; <b>const</b> R: TRect ): <b>Boolean</b>;</font>
<br>
Returns True if point P is located in rectangle R (including
left and top bounds but without right and bottom bounds of the
rectangle).
</p>
<a name="offsetpoint"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>OffsetPoint</b></font>( <b>const</b> T: TPoint; dX, dY: <b>Integer</b> ): TPoint;</font>
<br>
</p>
<a name="offsetsmallpoint"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>OffsetSmallPoint</b></font>( <b>const</b> T: TSmallPoint; dX, dY: SmallInt ): TSmallPoint;</font>
<br>
</p>
<a name="point2smallpoint"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Point2SmallPoint</b></font>( <b>const</b> T: TPoint ): TSmallPoint;</font>
<br>
</p>
<a name="smallpoint2point"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>SmallPoint2Point</b></font>( <b>const</b> T: TSmallPoint ): TPoint;</font>
<br>
</p>
<a name="makepoint"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>MakePoint</b></font>( X, Y: <b>Integer</b> ): TPoint;</font>
<br>
Use instead of VCL function Point
</p>
<a name="makesmallpoint"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>MakeSmallPoint</b></font>( X, Y: <b>Integer</b> ): TSmallPoint;</font>
<br>
Use to construct TSmallPoint
</p>
<a name="makeflags"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>MakeFlags</b></font>( FlgSet: PDWORD; FlgArray: <b>array</b> <b>of</b> <b>Integer</b> ): <b>Integer</b>;</font>
<br>
</p>
<a name="makedatetimerange"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>MakeDateTimeRange</b></font>( D1, D2: TDateTime ): TDateTimeRange;</font>
<br>
Returns TDateTimeRange from two TDateTime bounds.
</p>
<a name="swap"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>Swap</b></font>( <b>var</b> X, Y: <b>Integer</b> );</font>
<br>
exchanging values
</p>
<a name="min"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Min</b></font>( X, Y: <b>Integer</b> ): <b>Integer</b>;</font>
<br>
minimum of two integers
</p>
<a name="max"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Max</b></font>( X, Y: <b>Integer</b> ): <b>Integer</b>;</font>
<br>
maximum of two integers
</p>
<a name="abs"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Abs</b></font>( X: <b>Integer</b> ): <b>Integer</b>;</font>
<br>
absolute value
</p>
<a name="sgn"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Sgn</b></font>( X: <b>Integer</b> ): <b>Integer</b>;</font>
<br>
sign of X: if X &lt; 0, -1 is returned, if &gt; 0, then +1, otherwise 0.
</p>
<a name="isqrt"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>iSqrt</b></font>( X: <b>Integer</b> ): <b>Integer</b>;</font>
<br>
square root
</p>
<a name="icbrt"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>iCbrt</b></font>( X: <b>DWORD</b> ): <b>Integer</b>;</font>
<br>
cubic root
<hr>
<a name="String to number and number to string conversions"></a><font color=#FF8040><h1>String to number and number to string conversions</h1></font>

</p>
<a name="int2hex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Int2Hex</b></font>( Value: <b>DWord</b>; Digits: <b>Integer</b> ): AnsiString;</font>
<br>
Converts integer Value into string with hex number. Digits parameter
determines minimal number of digits (will be completed by adding
necessary number of leading zeroes).
</p>
<a name="int2str"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Int2Str</b></font>( Value: <b>Integer</b> ): AnsiString;</font>
<br>
Obvious.
</p>
<a name="int2pchar"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>Int2PChar</b></font>( s: PAnsiChar; Value: <b>Integer</b> );</font>
<br>
Converts Value to string and puts it into buffer s. Buffer must have
enough size to store the number converted: buffer overflow does
not checked anyway!
</p>
<a name="uint2str"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>UInt2Str</b></font>( Value: <b>DWORD</b> ): AnsiString;</font>
<br>
The same as <a href=#int2str>Int2Str</a>, but for unsigned integer value.
</p>
<a name="int2strex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Int2StrEx</b></font>( Value, MinWidth: <b>Integer</b> ): AnsiString;</font>
<br>
Like <a href=#int2str>Int2Str</a>, but resulting string filled with leading spaces to provide
at least MinWidth characters.
</p>
<a name="int2rome"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Int2Rome</b></font>( Value: <b>Integer</b> ): AnsiString;</font>
<br>
Represents number 1..8999 to Rome numer.
</p>
<a name="int2ths"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Int2Ths</b></font>( I: <b>Integer</b> ): AnsiString;</font>
<br>
Converts integer into string, separating every three digits from each
other by character ThsSeparator. (Convert to thousands). You
</p>
<a name="int2digs"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Int2Digs</b></font>( Value, Digits: <b>Integer</b> ): AnsiString;</font>
<br>
Converts integer to string, inserting necessary number of leading zeroes
to provide desired length of string, given by Digits parameter. If
resulting string is greater then Digits, string is not truncated anyway.
</p>
<a name="num2bytes"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Num2Bytes</b></font>( Value: <b>Double</b> ): AnsiString;</font>
<br>
Converts double float to string, considering it as a bytes count.
If Value is sufficiently large, number is represented in kilobytes (with
following letter K), or in megabytes (M), gigabytes (G) or terabytes (T).
Resulting string number is truncated to two decimals (.XX) or to one (.X),
if the second is 0.
</p>
<a name="s2int"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>S2Int</b></font>( S: PAnsiChar ): <b>Integer</b>;</font>
<br>
Converts null-terminated string to Integer. Scanning stopped when any
non-digit character found. Even empty string or string not containing
valid integer number silently converted to 0.
</p>
<a name="str2int"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Str2Int</b></font>( <b>const</b> Value: AnsiString ): <b>Integer</b>;</font>
<br>
Converts string to integer. First character, which can not be
recognized as a part of number, regards as a separator. Even
empty string or string without number silently converted to 0.
</p>
<a name="hex2int"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Hex2Int</b></font>( <b>const</b> Value: AnsiString ): <b>Integer</b>;</font>
<br>
Converts hexadecimal number to integer. Scanning is stopped
when first non-hexadicimal character is found. Leading dollar ('$')
character is skept (if present). Minus ('-') is not concerning as
a sign of number and also stops scanning.
</p>
<a name="chex2int"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>cHex2Int</b></font>( <b>const</b> Value: AnsiString ): <b>Integer</b>;</font>
<br>
As <a href=#hex2int>Hex2Int</a>, but also checks for leading '0x' and skips it.
</p>
<a name="octal2int"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Octal2Int</b></font>( <b>const</b> Value: AnsiString ): <b>Integer</b>;</font>
<br>
Converts octal number to integer. Scanning is stopped on first
non-octal digit (any char except 0..7). There are no checking if
there octal numer in the parameter. If the first char is not octal
digit, 0 is returned.
</p>
<a name="binary2int"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Binary2Int</b></font>( <b>const</b> Value: AnsiString ): <b>Integer</b>;</font>
<br>
Converts binary number to integer. Like <a href=#octal2int>Octal2Int</a>, but only digits
0 and 1 are allowed.
</p>
<a name="toradix"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ToRadix</b></font>( number: Radix_int; radix, min_digits: <b>Integer</b> ): KOLString;</font>
<br>
Converts unsigned number to string representing it literally in a numeric
base given by radix parameter.
</p>
<a name="fromradixstr"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FromRadixStr</b></font>( <b>var</b> Rslt: Radix_int; s: PKOLChar; radix: <b>Integer</b> ): PKOLChar;</font>
<br>
Converts unsigned number from string representation in a numeric base given by
a radix parameter. Returns a pointer to a character next to the last digit of
the number.
</p>
<a name="fromradix"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FromRadix</b></font>( <b>const</b> s: AnsiString; radix: <b>Integer</b> ): Radix_int;</font>
<br>
Converts unsigned number from string representation in a numeric base given by
a radix parameter. See also: <a href=#fromradixstr>FromRadixStr</a> function.
</p>
<a name="insertseparators"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>InsertSeparators</b></font>( <b>const</b> s: KOLString; chars_between: <b>Integer</b>; Separator: KOLChar ): KOLString;</font>
<br>
Inserts given Separator between symbols in s, separating each portion of
chars_between characters with a Separator starting from right side. See also:
<a href=#int2ths>Int2Ths</a> function.
</p>
<a name="format"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Format</b></font>( <b>const</b> fmt: KOLString; params: <b>array</b> <b>of</b> <b>const</b> ): KOLString;</font>
<br>
Uses API call to wvsprintf, so does not understand extra formats,
such as floating point, date/time, currency conversions. See list of
available formats in win32.hlp (topic wsprintf).
<hr>
<a name="Working with null-terminated and ansi strings"></a><font color=#FF8040><h1>Working with null-terminated and ansi strings</h1></font>

</p>
<a name="strcomp"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrComp</b></font>( <b>const</b> Str1, Str2: PAnsiChar ): <b>Integer</b>;</font>
<br>
Compares two strings fast. -1: Str1&lt;Str2; 0: Str1=Str2; +1: Str1&gt;Str2
</p>
<a name="strcomp_nocase"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrComp_NoCase</b></font>( <b>const</b> Str1, Str2: PAnsiChar ): <b>Integer</b>;</font>
<br>
Compares two strings fast without case sensitivity.
Returns: -1 when Str1&lt;Str2; 0 when Str1=Str2; +1 when Str1&gt;Str2
</p>
<a name="strlcomp_nocase"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrLComp_NoCase</b></font>( <b>const</b> Str1, Str2: PAnsiChar; MaxLen: Cardinal ): <b>Integer</b>;</font>
<br>
Compare two strings fast without case sensitivity.
Terminating 0 is not considered, so if strings are equal,
comparing is continued up to MaxLen bytes.
Since this, pass minimum of lengths as MaxLen.
</p>
<a name="strcomp_nocase"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>StrComp_NoCase</b></font>: <b>function</b>( <b>const</b> Str1, Str2: PAnsiChar ): <b>Integer</b> = StrComp_NoCase1;</font>
<br>
Compares two strings fast without case sensitivity.
Returns: -1 when Str1&lt;Str2; 0 when Str1=Str2; +1 when Str1&gt;Str2
</p>
<a name="strlcomp"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrLComp</b></font>( <b>const</b> Str1, Str2: PAnsiChar; MaxLen: Cardinal ): <b>Integer</b>;</font>
<br>
Compare two strings (fast). Terminating 0 is not considered, so if
strings are equal, comparing is continued up to MaxLen bytes.
Since this, pass minimum of lengths as MaxLen.
</p>
<a name="strcopy"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrCopy</b></font>( Dest, Source: PAnsiChar ): PAnsiChar;</font>
<br>
Copy source string to destination (fast). Pointer to Dest is returned.
</p>
<a name="strcat"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrCat</b></font>( Dest, Source: PAnsiChar ): PAnsiChar;</font>
<br>
Append source string to destination (fast). Pointer to Dest is returned.
</p>
<a name="strlen"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrLen</b></font>( <b>const</b> Str: PAnsiChar ): Cardinal;</font>
<br>
StrLen returns the number of characters in Str, not counting the null
terminator.
</p>
<a name="strscanlen"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrScanLen</b></font>( Str: PAnsiChar; Chr: AnsiChar; Len: <b>Integer</b> ): PAnsiChar;</font>
<br>
Fast scans string Str of length Len searching character Chr.
Pointer to a character next to found or to Str[Len] (if no one found)
is returned.
</p>
<a name="strscan"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrScan</b></font>( Str: PAnsiChar; Chr: AnsiChar ): PAnsiChar;</font>
<br>
Fast search of given character in a string. Pointer to found character
(or nil) is returned.
</p>
<a name="strrscan"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrRScan</b></font>( <b>const</b> Str: PAnsiChar; Chr: AnsiChar ): PAnsiChar;</font>
<br>
StrRScan returns a pointer to the last occurrence of Chr in Str. If Chr
does not occur in Str, StrRScan returns NIL. The null terminator is
considered to be part of the string.
</p>
<a name="strisstartingfrom"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrIsStartingFrom</b></font>( Str, Pattern: PKOLChar ): <b>Boolean</b>;</font>
<br>
Returns True, if string Str is starting from Pattern, i.e. if
Copy( Str, 1, <a href=#strlen>StrLen</a>( Pattern ) ) = Pattern. Str must not be nil!
</p>
<a name="strisstartingfromnocase"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrIsStartingFromNoCase</b></font>( Str, Pattern: PAnsiChar ): <b>Boolean</b>;</font>
<br>
Like <a href=#strisstartingfrom>StrIsStartingFrom</a> above, but without case sensitivity.
</p>
<a name="trimleft"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>TrimLeft</b></font>( <b>const</b> S: KOLString ): KOLString;</font>
<br>
Removes spaces, tabulations and control characters from the starting
of string S.
</p>
<a name="trimright"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>TrimRight</b></font>( <b>const</b> S: KOLString ): KOLString;</font>
<br>
Removes spaces, tabulates and other control characters from the
end of string S.
</p>
<a name="trim"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Trim</b></font>( <b>const</b> S: KOLString ): KOLString;</font>
<br>
Makes <a href=#trimleft>TrimLeft</a> and <a href=#trimright>TrimRight</a> for given string.
</p>
<a name="removespaces"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RemoveSpaces</b></font>( <b>const</b> S: KOLString ): KOLString;</font>
<br>
Removes all characters less or equal to ' ' in S and returns it.
</p>
<a name="str2lowercase"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>Str2LowerCase</b></font>( S: PAnsiChar );</font>
<br>
Converts null-terminated string to lowercase (inplace).
</p>
<a name="lowercase"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>LowerCase</b></font>( <b>const</b> S: Ansistring ): Ansistring;</font>
<br>
Obvious.
</p>
<a name="uppercase"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>UpperCase</b></font>( <b>const</b> S: Ansistring ): Ansistring;</font>
<br>
Obvious.
</p>
<a name="ansiuppercase"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>AnsiUpperCase</b></font>( <b>const</b> S: Ansistring ): Ansistring;</font>
<br>
Obvious.
</p>
<a name="ansilowercase"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>AnsiLowerCase</b></font>( <b>const</b> S: Ansistring ): Ansistring;</font>
<br>
Obvious.
</p>
<a name="wansiuppercase"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WAnsiUpperCase</b></font>( <b>const</b> S: WideString ): WideString;</font>
<br>
Obvious.
</p>
<a name="wansilowercase"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WAnsiLowerCase</b></font>( <b>const</b> S: WideString ): WideString;</font>
<br>
Obvious.
</p>
<a name="wstrcomp"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WStrComp</b></font>( <b>const</b> S1, S2: WideString ): <b>Integer</b>;</font>
<br>
</p>
<a name="_wstrcomp"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>_WStrComp</b></font>( S1, S2: PWideChar ): <b>Integer</b>;</font>
<br>
</p>
<a name="wstrscan"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WStrScan</b></font>( Str: PWideChar; Chr: WideChar ): PWideChar;</font>
<br>
Fast search of given character in a string. Pointer to found character
(or nil) is returned.
</p>
<a name="wstrrscan"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WStrRScan</b></font>( <b>const</b> Str: PWideChar; Chr: WideChar ): PWideChar;</font>
<br>
<a href=#strrscan>StrRScan</a> returns a pointer to the last occurrence of Chr in Str. If Chr
does not occur in Str, <a href=#strrscan>StrRScan</a> returns NIL. The null terminator is
considered to be part of the string.
</p>
<a name="ansicomparestr"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>AnsiCompareStr</b></font>( <b>const</b> S1, S2: KOLString ): <b>Integer</b>;</font>
<br>
AnsiCompareStr compares S1 to S2, with case-sensitivity. The compare
operation is controlled by the current Windows locale. The return value
is the same as for CompareStr.
</p>
<a name="_ansicomparestr"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>_AnsiCompareStr</b></font>( S1, S2: PKOLChar ): <b>Integer</b>;</font>
<br>
The same, but for PChar ANSI strings
</p>
<a name="ansicomparestrnocase"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>AnsiCompareStrNoCase</b></font>( <b>const</b> S1, S2: KOLString ): <b>Integer</b>;</font>
<br>
<a href=#ansicomparestr>AnsiCompareStr</a> compares S1 to S2, with case-sensitivity. The compare
operation is controlled by the current Windows locale. The return value
is the same as for CompareStr.
</p>
<a name="_ansicomparestrnocase"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>_AnsiCompareStrNoCase</b></font>( S1, S2: PKOLChar ): <b>Integer</b>;</font>
<br>
The same, but for PChar ANSI strings
</p>
<a name="ansicomparetext"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>AnsiCompareText</b></font>( <b>const</b> S1, S2: KOLString ): <b>Integer</b>;</font>
<br>
</p>
<a name="ansieq"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>AnsiEq</b></font>( <b>const</b> S1, S2: KOLString ): <b>Boolean</b>;</font>
<br>
Returns True, if <a href=#ansilowercase>AnsiLowerCase</a>(S1) = <a href=#ansilowercase>AnsiLowerCase</a>(S2). I.e., if ANSI
stringsare equal to each other without caring of characters case
sensitivity.
</p>
<a name="ansicomparestra"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>AnsiCompareStrA</b></font>( <b>const</b> S1, S2: AnsiString ): <b>Integer</b>;</font>
<br>
<a href=#ansicomparestr>AnsiCompareStr</a> compares S1 to S2, with case-sensitivity. The compare
operation is controlled by the current Windows locale. The return value
is the same as for CompareStr.
</p>
<a name="_ansicomparestra"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>_AnsiCompareStrA</b></font>( S1, S2: PAnsiChar ): <b>Integer</b>;</font>
<br>
The same, but for PChar ANSI strings
</p>
<a name="ansicomparestrnocasea"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>AnsiCompareStrNoCaseA</b></font>( <b>const</b> S1, S2: AnsiString ): <b>Integer</b>;</font>
<br>
<a href=#ansicomparestr>AnsiCompareStr</a> compares S1 to S2, with case-sensitivity. The compare
operation is controlled by the current Windows locale. The return value
is the same as for CompareStr.
</p>
<a name="_ansicomparestrnocasea"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>_AnsiCompareStrNoCaseA</b></font>( S1, S2: PAnsiChar ): <b>Integer</b>;</font>
<br>
The same, but for PChar ANSI strings
</p>
<a name="ansicomparetexta"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>AnsiCompareTextA</b></font>( <b>const</b> S1, S2: AnsiString ): <b>Integer</b>;</font>
<br>
</p>
<a name="lstrfrompwcharlen"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>LStrFromPWCharLen</b></font>( Source: PWideChar; Length: <b>Integer</b> ): AnsiString;</font>
<br>
from Delphi5 - because D2 does not contain it.
</p>
<a name="lstrfrompwchar"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>LStrFromPWChar</b></font>( Source: PWideChar ): AnsiString;</font>
<br>
from Delphi5 - because D2 does not contain it.
</p>
<a name="copyend"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CopyEnd</b></font>( <b>const</b> S: KOLString; Idx: <b>Integer</b> ): KOLString;</font>
<br>
Returns copy of source string S starting from Idx up to the end of
string S. Works correctly for case, when Idx &gt; Length( S ) (returns
empty string for such case).
</p>
<a name="copytail"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CopyTail</b></font>( <b>const</b> S: KOLString; Len: <b>Integer</b> ): KOLString;</font>
<br>
Returns last Len characters of the source string. If Len &gt; Length( S ),
entire string S is returned.
</p>
<a name="deletetail"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>DeleteTail</b></font>( <b>var</b> S: KOLString; Len: <b>Integer</b> );</font>
<br>
Deletes last Len characters from string.
</p>
<a name="indexofchar"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>IndexOfChar</b></font>( <b>const</b> S: KOLString; Chr: KOLChar ): <b>Integer</b>;</font>
<br>
Returns index of given character (1..Length(S)), or
-1 if a character not found.
</p>
<a name="indexofcharsmin"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>IndexOfCharsMin</b></font>( <b>const</b> S, Chars: KOLString ): <b>Integer</b>;</font>
<br>
Returns index (in string S) of those character, what is taking place
in Chars string and located nearest to start of S. If no such
characters in string S found, -1 is returned.
</p>
<a name="indexofwidecharsmin"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>IndexOfWideCharsMin</b></font>( <b>const</b> S, Chars: WideString ): <b>Integer</b>;</font>
<br>
Returns index (in wide string S) of those wide character, what
is taking place in Chars wide string and located nearest to start of S.
If no such characters in string S found, -1 is returned.
</p>
<a name="indexofstr"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>IndexOfStr</b></font>( <b>const</b> S, Sub: KOLString ): <b>Integer</b>;</font>
<br>
Returns index of given substring in source string S. If found,
1..Length(S)-Length(Sub), if not found, -1.
</p>
<a name="parse"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Parse</b></font>( <b>var</b> S: KOLString; <b>const</b> Separators: KOLString ): KOLString;</font>
<br>
Returns first characters of string S, separated from others by
one of characters, taking place in Separators string, assigning
a tail of string (after found separator) to source string. If
no separator characters found, source string S is returned, and
source string itself becomes empty.
</p>
<a name="wparse"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WParse</b></font>( <b>var</b> S: WideString; <b>const</b> Separators: WideString ): WideString;</font>
<br>
Returns first wide characters of wide string S, separated from others
by one of wide characters, taking place in Separators wide string,
assigning a tail of wide string (following found separator) to the
source one. If there are no separator characters found, source wide
string S is returned, and source wide string itself becomes empty.
</p>
<a name="parsepascalstring"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ParsePascalString</b></font>( <b>var</b> S: AnsiString; <b>const</b> Separators: AnsiString ): AnsiString;</font>
<br>
Returns first characters of string S, separated from others by
one of characters, taking place in Separators string, assigning
a tail of string (after the found separator) to source string. If
there are no separator characters found, the source string S is returned,
and the source string itself becomes empty. Additionally: if the first (after
a blank space) is the quote &quot;'&quot; or '#', pascal string is assumung first
and is converted to usual string (without quotas) before analizing
of other separators.
</p>
<a name="string2pascalstrexpr"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>String2PascalStrExpr</b></font>( <b>const</b> S: AnsiString ): AnsiString;</font>
<br>
Converts string to Pascal-like string expression (concatenation of
strings with quotas and characters with leading '#').
</p>
<a name="streq"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrEq</b></font>( <b>const</b> S1, S2: AnsiString ): <b>Boolean</b>;</font>
<br>
Returns True, if <a href=#lowercase>LowerCase</a>(S1) = <a href=#lowercase>LowerCase</a>(S2). I.e., if strings
are equal to each other without caring of characters case sensitivity
(ASCII only).
</p>
<a name="wansieq"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WAnsiEq</b></font>( <b>const</b> S1, S2: WideString ): <b>Boolean</b>;</font>
<br>
Returns True, if <a href=#ansilowercase>AnsiLowerCase</a>(S1) = <a href=#ansilowercase>AnsiLowerCase</a>(S2). I.e., if ANSI
stringsare equal to each other without caring of characters case
sensitivity.
</p>
<a name="strin"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrIn</b></font>( <b>const</b> S: AnsiString; <b>const</b> A: <b>array</b> <b>of</b> <b>String</b> ): <b>Boolean</b>;</font>
<br>
Returns True, if S is &quot;equal&quot; to one of strings, taking place
in A array. To check equality, <a href=#streq>StrEq</a> function is used, i.e.
comaprison is taking place without case sensitivity.
</p>
<a name="wstrin"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WStrIn</b></font>( <b>const</b> S: WideString; <b>const</b> A: <b>array</b> <b>of</b> WideString ): <b>Boolean</b>;</font>
<br>
Returns True, if S is &quot;equal&quot; to one of strings, taking place
in A array. To check equality, <a href=#wansieq>WAnsiEq</a> function is used, i.e.
comaprison is taking place without case sensitivity.
</p>
<a name="charin"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CharIn</b></font>( C: KOLChar; <b>const</b> A: TSetOfChar ): <b>Boolean</b>;</font>
<br>
To replace expressions like S[1] in [ '0'..'z' ] to CharIn( S[ 1 ], [ '0'..'z' ] )
(and to avoid problems with Unicode version of code).
</p>
<a name="stris"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrIs</b></font>( <b>const</b> S: AnsiString; <b>const</b> A: <b>Array</b> <b>of</b> AnsiString; <b>var</b> Idx: <b>Integer</b> ): <b>Boolean</b>;</font>
<br>
Returns True, if S is &quot;equal&quot; to one of strings, taking place
in A array, and in such Case Idx also is assigned to an index of A element
equal to S. To check equality, <a href=#streq>StrEq</a> function is used, i.e.
comaprison is taking place without case sensitivity.
</p>
<a name="intin"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>IntIn</b></font>( Value: <b>Integer</b>; <b>const</b> List: <b>array</b> <b>of</b> <b>Integer</b> ): <b>Boolean</b>;</font>
<br>
Returns TRUE, if Value is found in a List.
</p>
<a name="_strsatisfy"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>_StrSatisfy</b></font>( S, Mask: PKOLChar ): <b>Boolean</b>;</font>
<br>
</p>
<a name="_2strsatisfy"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>_2StrSatisfy</b></font>( S, Mask: PKOLChar ): <b>Boolean</b>;</font>
<br>
</p>
<a name="strsatisfy"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrSatisfy</b></font>( <b>const</b> S, Mask: KOLString ): <b>Boolean</b>;</font>
<br>
Returns True, if S is satisfying to a given Mask (which can contain
wildcard symbols '*' and '?' interpeted correspondently as 'any
set of characters' and 'single any character'. If there are no
such wildcard symbols in a Mask, result is True only if S is maching
to Mask string.)
</p>
<a name="strreplace"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrReplace</b></font>( <b>var</b> S: AnsiString; <b>const</b> From, ReplTo: AnsiString ): <b>Boolean</b>;</font>
<br>
Replaces first occurance of From to ReplTo in S, returns True,
if pattern From was found and replaced.
</p>
<a name="kolstrreplace"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>KOLStrReplace</b></font>( <b>var</b> S: KOLString; <b>const</b> From, ReplTo: KOLString ): <b>Boolean</b>;</font>
<br>
Replaces first occurance of From to ReplTo in S, returns True,
if pattern From was found and replaced.
</p>
<a name="wstrreplace"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WStrReplace</b></font>( <b>var</b> S: WideString; <b>const</b> From, ReplTo: WideString ): <b>Boolean</b>;</font>
<br>
Replaces first occurance of From to ReplTo in S, returns True,
if pattern From was found and replaced. See also function <a href=#strreplace>StrReplace</a>.
This function is not available in Delphi2 (this version of Delphi
does not support WideString type).
</p>
<a name="strrepeat"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrRepeat</b></font>( <b>const</b> S: AnsiString; Count: <b>Integer</b> ): AnsiString;</font>
<br>
Repeats given string Count times. E.g., StrRepeat( 'A', 5 ) gives 'AAAAA'.
</p>
<a name="wstrrepeat"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WStrRepeat</b></font>( <b>const</b> S: WideString; Count: <b>Integer</b> ): WideString;</font>
<br>
Repeats given wide string Count times. E.g., <a href=#strrepeat>StrRepeat</a>( 'A', 5 ) gives 'AAAAA'.
</p>
<a name="normalizeunixtext"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>NormalizeUnixText</b></font>( <b>var</b> S: AnsiString );</font>
<br>
In the string S, replaces all occurances of character #10 (without leading #13)
to the character #13.
</p>
<a name="koi8toansi"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>Koi8ToAnsi</b></font>( s: PAnsiChar );</font>
<br>
Converts Koi8 text to Ansi (in place)
</p>
<a name="strpcopy"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrPCopy</b></font>( Dest: PAnsiChar; <b>const</b> Source: Ansistring ): PAnsiChar;</font>
<br>
Copyes Pascal-style string into null-terminaed one.
</p>
<a name="strlcopy"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrLCopy</b></font>( Dest: PAnsiChar; <b>const</b> Source: PAnsiChar; MaxLen: Cardinal ): PAnsiChar;</font>
<br>
Copyes first MaxLen characters of Pascal-style string into
null-terminated one.
</p>
<a name="delimiterlast"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DelimiterLast</b></font>( <b>const</b> Str, Delimiters: KOLString ): <b>Integer</b>;</font>
<br>
Returns index of the last of delimiters given by same named parameter
among characters of Str. If there are no delimiters found, length of
Str is returned. This function is intended mainly to use in filename
parsing functions.
</p>
<a name="__delimiterlast"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>__DelimiterLast</b></font>( Str, Delimiters: PKOLChar ): PKOLChar;</font>
<br>
Returns address of the last of delimiters given by Delimiters parameter
among characters of Str. If there are no delimeters found, position of
the null terminator in Str is returned. This function is intended
mainly to use in filename parsing functions.
</p>
<a name="w__delimiterlast"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>W__DelimiterLast</b></font>( Str, Delimiters: PWideChar ): PWideChar;</font>
<br>
</p>
<a name="skipspaces"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>SkipSpaces</b></font>( P: PKOLChar ): PKOLChar;</font>
<br>
Skips all characters #1..' ' in a string.
</p>
<a name="comparemem"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CompareMem</b></font>( P1, P2: <b>Pointer</b>; Length: <b>Integer</b> ): <b>Boolean</b>;</font>
<br>
Fast compare of two memory blocks.
</p>
<a name="allocmem"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>AllocMem</b></font>( Size: <b>Integer</b> ): <b>Pointer</b>;</font>
<br>
Allocates global memory and unlocks it.
</p>
<a name="disposemem"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>DisposeMem</b></font>( <b>var</b> Addr: <b>Pointer</b> );</font>
<br>
Locks global memory block given by pointer, and frees it.
Does nothing, if the pointer is nil.
<hr>
<a name="Text in clipboard operations"></a><font color=#FF8040><h1>Text in clipboard operations</h1></font>

</p>
<a name="clipboardhastext"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ClipboardHasText</b></font>: <b>Boolean</b>;</font>
<br>
Returns true, if the clipboard contain text to paste from.
</p>
<a name="clipboard2text"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Clipboard2Text</b></font>: AnsiString;</font>
<br>
If clipboard contains text, this function returns it for You.
</p>
<a name="clipboard2wtext"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Clipboard2WText</b></font>: WideString;</font>
<br>
If clipboard contains text, this function returns it for You (as Unicode string).
</p>
<a name="text2clipboard"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Text2Clipboard</b></font>( <b>const</b> S: AnsiString ): <b>Boolean</b>;</font>
<br>
Puts given string to a clipboard.
</p>
<a name="wtext2clipboard"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WText2Clipboard</b></font>( <b>const</b> WS: WideString ): <b>Boolean</b>;</font>
<br>
Puts given Unicode string to a clipboard.
<hr>
</p>
<a name="supportansimnemonics"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>SupportAnsiMnemonics</b></font>( LocaleID: <b>Integer</b> );</font>
<br>
Provides encoding to work with given locale. Call this global function to
extend <a href=tcontrol.htm#supportmnemonics>TControl.SupportMnemonics</a> capability (also should be called for a form
or for <a href=#applet>Applet</a> variable).
<a name="Date and time handling"></a><font color=#FF8040><h1>Date and time handling</h1></font>

</p>
<a name="tdateformat"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TDateFormat</b></font> =( dfShortDate, dfLongDate );</font>
<br>
<a href=#date>Date</a> formats available to use in formatting date/time to string.
</p>
<a name="ttimeformatflag"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TTimeFormatFlag</b></font> =( tffNoMinutes, tffNoSeconds, tffNoMarker, tffForce24 );</font>
<br>
Additional flags, used for formatting time.
</p>
<a name="ttimeformatflags"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TTimeFormatFlags</b></font> = <b>Set</b> <b>of</b> <a href=#ttimeformatflag>TTimeFormatFlag</a>;</font>
<br>
Set of flags, used for formatting time.
</p>
<a name="monthdays"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>MonthDays</b></font>: array[ <b>Boolean</b> ] <b>of</b> TDayTable =(( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ),( 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ) );</font>
<br>
The MonthDays array can be used to quickly find the number of
days in a month:  MonthDays[<a href=#isleapyear>IsLeapYear</a>(Y), M].
</p>
<a name="secsperday"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>SecsPerDay</b></font> = 24* 60* 60;</font>
<br>
Seconds per day.
</p>
<a name="msecsperday"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>MSecsPerDay</b></font> = SecsPerDay* 1000;</font>
<br>
Milliseconds per day.
</p>
<a name="vcldate0"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>VCLDate0</b></font> = 693594;</font>
<br>
Value to convert VCL &quot;date 0&quot; to KOL &quot;date 0&quot; and back.
This value corresponds to 30-Dec-1899, 0:00:00. So,
to convert VCL date to KOL date, just subtract this
value from VCL date. And to convert back from KOL date
to VCL date, add this value to KOL date.
</p>
<a name="now"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Now</b></font>: TDateTime;</font>
<br>
Returns local date and time on running PC.
</p>
<a name="date"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Date</b></font>: TDateTime;</font>
<br>
Returns todaylocal date.
</p>
<a name="decodedatefully"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>DecodeDateFully</b></font>( DateTime: TDateTime; <b>var</b> Year, Month, Day, <a href=#dayofweek>DayOfWeek</a>: <b>WORD</b> );</font>
<br>
Decodes date.
</p>
<a name="decodedate"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>DecodeDate</b></font>( DateTime: TDateTime; <b>var</b> Year, Month, Day: <b>WORD</b> );</font>
<br>
Decodes date.
</p>
<a name="encodedate"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>EncodeDate</b></font>( Year, Month, Day: <b>WORD</b>; <b>var</b> DateTime: TDateTime ): <b>Boolean</b>;</font>
<br>
Encodes date.
</p>
<a name="comparesystemtime"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CompareSystemTime</b></font>( <b>const</b> D1, D2: TSystemTime ): <b>Integer</b>;</font>
<br>
Compares to TSystemTime records. Returns -1, 0, or 1 if, correspondantly,
D1 &lt; D2, D1 = D2 and D1 &gt; D2.
</p>
<a name="incdays"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>IncDays</b></font>( <b>var</b> SystemTime: TSystemTime; DaysNum: <b>Integer</b> );</font>
<br>
Increases/decreases day in TSystemTime record onto given days count
(can be negative).
</p>
<a name="incmonths"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>IncMonths</b></font>( <b>var</b> SystemTime: TSystemTime; MonthsNum: <b>Integer</b> );</font>
<br>
Increases/decreases month number in TSystemTime record onto given
months count (can be negative). Correct result is not garantee if
day number is incorrect for newly obtained month.
</p>
<a name="isleapyear"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>IsLeapYear</b></font>( Year: <b>Integer</b> ): <b>Boolean</b>;</font>
<br>
Returns True, if given year is &quot;leap&quot; (i.e. has 29 days in the February).
</p>
<a name="dayofweek"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DayOfWeek</b></font>( <a href=#date>Date</a>: TDateTime ): <b>Integer</b>;</font>
<br>
Returns day of week (0..6) for given date.
</p>
<a name="systemtime2datetime"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>SystemTime2DateTime</b></font>( <b>const</b> SystemTime: TSystemTime; <b>var</b> DateTime: TDateTime ): <b>Boolean</b>;</font>
<br>
Converts TSystemTime record to XDateTime variable.
</p>
<a name="datetime2systemtime"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DateTime2SystemTime</b></font>( <b>const</b> DateTime: TDateTime; <b>var</b> SystemTime: TSystemTime ): <b>Boolean</b>;</font>
<br>
Converts TDateTime variable to TSystemTime record.
</p>
<a name="datetime_system2local"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DateTime_System2Local</b></font>( DTSys: TDateTime ): TDateTime;</font>
<br>
Converts DTSys representing system time (+0 Grinvich) to local time.
</p>
<a name="datetime_local2system"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DateTime_Local2System</b></font>( DTLoc: TDateTime ): TDateTime;</font>
<br>
Converts DTLoc representing local time to system time (+0 Grinvich)
</p>
<a name="filetime2datetime"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FileTime2DateTime</b></font>( <b>const</b> ft: TFileTime; <b>var</b> DT: TDateTime ): <b>Boolean</b>;</font>
<br>
</p>
<a name="datetime2filetime"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DateTime2FileTime</b></font>( DT: TDateTime; <b>var</b> ft: TFileTime ): <b>Boolean</b>;</font>
<br>
</p>
<a name="divmod"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>DivMod</b></font>( Dividend: <b>Integer</b>; Divisor: <b>Word</b>; <b>var</b> Result, Remainder: <b>Word</b> );</font>
<br>
Dividing of integer onto divisor with obtaining both result of division
and remainder.
</p>
<a name="systemdate2str"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>SystemDate2Str</b></font>( <b>const</b> SystemTime: TSystemTime; <b>const</b> LocaleID: <b>DWORD</b>; <b>const</b> DfltDateFormat: <a href=#tdateformat>TDateFormat</a>; <b>const</b> DateFormat: PKOLChar ): KOLString;</font>
<br>
Formats date, stored in TSystemTime record into string, using given locale
and date/time formatting flags. (E.g.: GetUserDefaultLangID).
</p>
<a name="systemtime2str"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>SystemTime2Str</b></font>( <b>const</b> SystemTime: TSystemTime; <b>const</b> LocaleID: <b>DWORD</b>; <b>const</b> Flags: <a href=#ttimeformatflags>TTimeFormatFlags</a>; <b>const</b> TimeFormat: PKOLChar ): KOLString;</font>
<br>
Formats time, stored in TSystemTime record into string, using given locale
and date/time formatting flags.
</p>
<a name="date2strfmt"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Date2StrFmt</b></font>( <b>const</b> Fmt: KOLString; D: TDateTime ): KOLString;</font>
<br>
Represents date as a string correspondently to Fmt formatting string.
See possible pictures in definition of the function <a href=#str2datetimefmt>Str2DateTimeFmt</a>
(the first part). If Fmt string is empty, default system date format
for short date string used.
</p>
<a name="time2strfmt"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Time2StrFmt</b></font>( <b>const</b> Fmt: KOLString; D: TDateTime ): KOLString;</font>
<br>
Represents time as a string correspondently to Fmt formatting string.
See possible pictures in definition of the function <a href=#str2datetimefmt>Str2DateTimeFmt</a>
(the second part). If Fmt string is empty, default system time format
for short date string used.
</p>
<a name="datetime2strshort"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DateTime2StrShort</b></font>( D: TDateTime ): KOLString;</font>
<br>
Formats date and time to string in short date format using current user
locale.
</p>
<a name="str2datetimefmt"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Str2DateTimeFmt</b></font>( <b>const</b> sFmtStr, sS: KOLString ): TDateTime;</font>
<br>
Restores date or/and time from string correspondently to a format string.
<a href=#date>Date</a> and time formatting string can contain following pictures (case
sensitive):
<pre>
DATE PICTURES
d    Day of the month as digits without leading zeros for single digit days.
dd   Day of the month as digits with leading zeros for single digit days
ddd  Day of the week as a 3-letter abbreviation as specified by a
LOCALE_SABBREVDAYNAME value.
dddd Day of the week as specified by a LOCALE_SDAYNAME value.
M    Month as digits without leading zeros for single digit months.
MM   Month as digits with leading zeros for single digit months
MMM  Month as a three letter abbreviation as specified by a LOCALE_SABBREVMONTHNAME value.
MMMM Month as specified by a LOCALE_SMONTHNAME value.
y    Year represented only be the last digit.
yy   Year represented only be the last two digits.
yyyy Year represented by the full 4 digits.
gg   Period/era string as specified by the CAL_SERASTRING value. The gg
format picture in a date string is ignored if there is no associated era
string. In Enlish locales, usual values are BC or AD.
TIME PICTURES
h    Hours without leading zeros for single-digit hours (12-hour clock).
hh   Hours with leading zeros for single-digit hours (12-hour clock).
H    Hours without leading zeros for single-digit hours (24-hour clock).
HH   Hours with leading zeros for single-digit hours (24-hour clock).
m    Minutes without leading zeros for single-digit minutes.
mm   Minutes with leading zeros for single-digit minutes.
s    Seconds without leading zeros for single-digit seconds.
ss   Seconds with leading zeros for single-digit seconds.
t    One character–time marker string (usually P or A, in English locales).
tt   Multicharacter–time marker string (usually PM or AM, in English locales).
</pre>
E.g., 'D, yyyy/MM/dd h:mm:ss'.
See also <a href=#str2datetimeshort>Str2DateTimeShort</a> function.
</p>
<a name="str2datetimeshort"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Str2DateTimeShort</b></font>( <b>const</b> S: KOLString ): TDateTime;</font>
<br>
Restores date and time from string correspondently to current user locale.
</p>
<a name="str2datetimeshortex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Str2DateTimeShortEx</b></font>( <b>const</b> S: KOLString ): TDateTime;</font>
<br>
Like <a href=#str2datetimeshort>Str2DateTimeShort</a> above, but uses locale defined date and time
separators to avoid recognizing time as a date in some cases.
<hr>
<a name="File and directory routines"></a><font color=#FF8040><h1>File and directory routines</h1></font>

</p>
<a name="ofopenread"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofOpenRead</b></font> = O_RDONLY $80000000;</font>
<br>
Use this flag (in combination with others) to open file for &quot;read&quot; only.
</p>
<a name="ofopenwrite"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofOpenWrite</b></font> = O_WRONLY $40000000;</font>
<br>
Use this flag (in combination with others) to open file for &quot;write&quot; only.
</p>
<a name="ofopenreadwrite"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofOpenReadWrite</b></font> = O_RDWR $C0000000;</font>
<br>
Use this flag (in combination with others) to open file for &quot;read&quot; and &quot;write&quot;.
</p>
<a name="ofshareexclusive"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofShareExclusive</b></font> = $10 $00;</font>
<br>
Use this flag (in combination with others) to open file for exclusive use.
</p>
<a name="ofsharedenywrite"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofShareDenyWrite</b></font> = $20 $01;</font>
<br>
Use this flag (in combination with others) to open file in share mode, when
only attempts to open it in other process for &quot;write&quot; will be impossible.
I.e., other processes could open this file simultaneously for read only
access.
</p>
<a name="ofsharedenyread"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofShareDenyRead</b></font> = 0 $02;</font>
<br>
Use this flag (in combination with others) to open file in share mode, when
only attempts to open it for &quot;read&quot; in other processes will be disabled.
I.e., other processes could open it for &quot;write&quot; only access.
</p>
<a name="ofsharedenynone"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofShareDenyNone</b></font> = $30 $03;</font>
<br>
Use this flag (in combination with others) to open file in full sharing mode.
I.e. any process will be able open this file using the same share flag.
</p>
<a name="ofcreatenew"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofCreateNew</b></font> = O_CREAT or O_TRUNC $100;</font>
<br>
Default creation disposition. Use this flag for creating new file (usually
for write access.
</p>
<a name="ofcreatealways"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofCreateAlways</b></font> = O_CREAT $200;</font>
<br>
Use this flag (in combination with others) to open existing or creating new
file. If existing file is opened, it is truncated to size 0.
</p>
<a name="ofopenexisting"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofOpenExisting</b></font> = 0 $300;</font>
<br>
Use this flag (in combination with others) to open existing file only.
</p>
<a name="ofopenalways"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofOpenAlways</b></font> = O_CREAT $400;</font>
<br>
Use this flag (in combination with others) to open existing or create new
(if such file is not yet exists).
</p>
<a name="oftruncateexisting"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofTruncateExisting</b></font> = O_TRUNC $500;</font>
<br>
Use this flag (in combination with others) to open existing file and truncate
it to size 0.
</p>
<a name="ofattrreadonly"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofAttrReadOnly</b></font> = 0 $10000;</font>
<br>
Use this flag to create Read-Only file (?).
</p>
<a name="ofattrhidden"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofAttrHidden</b></font> = 0 $20000;</font>
<br>
Use this flag to create hidden file.
</p>
<a name="ofattrsystem"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofAttrSystem</b></font> = 0 $40000;</font>
<br>
Use this flag to create system file.
</p>
<a name="ofattrtemp"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofAttrTemp</b></font> = 0 $1000000;</font>
<br>
Use this flag to create temp file.
</p>
<a name="ofattrarchive"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofAttrArchive</b></font> = 0 $200000;</font>
<br>
Use this flag to create archive file.
</p>
<a name="ofattrcompressed"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofAttrCompressed</b></font> = 0 $8000000;</font>
<br>
Use this flag to create compressed file. Has effect only on NTFS, and
only if ofAttrCompressed is not specified also.
</p>
<a name="ofattroffline"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>ofAttrOffline</b></font> = 0 $10000000;</font>
<br>
Use this flag to create offline file.
</p>
<a name="wfilecreate"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WFileCreate</b></font>( <b>const</b> FileName: WideString; OpenFlags: <b>DWord</b> ): THandle;</font>
<br>
</p>
<a name="filecreate"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FileCreate</b></font>( <b>const</b> FileName: KOLString; OpenFlags: <b>DWord</b> ): THandle;</font>
<br>
Call this function to open existing or create new file. OpenFlags
parameter can be a combination of up to three flags (by one from
each group:
<table border=0>
<tr><td valign=top>ofOpenRead, ofOpenWrite, ofOpenReadWrite</td><td valign=top>
- 1st group. Here You decide
wish You open file for read, write or read-and-write operations;
</td></tr>

<tr><td valign=top>ofShareExclusive, ofShareDenyWrite, ofShareDenyRead, ofShareDenyNone</td><td valign=top>
-2nd
group - sharing. Here You can mark out sharing mode, which is used to
open file.
</td></tr>

<tr><td valign=top>ofCreateNew, ofCreateAlways, ofOpenExisting, ofOpenAlways, ofTruncateExisting</td><td valign=top>

- 3rd group - creation disposition. Here You determine, either to create new
or open existing file and if to truncate existing or not.
</table>
</p>
<a name="fileclose"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FileClose</b></font>( Handle: THandle ): <b>Boolean</b>;</font>
<br>
Call it to close opened earlier file.
</p>
<a name="fileexists"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FileExists</b></font>( <b>const</b> FileName: KOLString ): <b>Boolean</b>;</font>
<br>
Returns True, if given file exists.
<br>Note (by Dod):
It is not documented in a help for GetFileAttributes, but it seems that
under NT-based Windows systems, FALSE is always returned for files
opened for excluseve use like pagefile.sys.
</p>
<a name="wfileexists"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WFileExists</b></font>( <b>const</b> FileName: WideString ): <b>Boolean</b>;</font>
<br>
Returns True, if given file exists.
<br>Note (by Dod):
It is not documented in a help for GetFileAttributes, but it seems that
under NT-based Windows systems, FALSE is always returned for files
opened for excluseve use like pagefile.sys.
</p>
<a name="fileseek"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FileSeek</b></font>( Handle: THandle; <b>const</b> MoveTo: TStrmMove; MoveMethod: TMoveMethod ): TStrmSize;</font>
<br>
Changes current position in file.
</p>
<a name="fileread"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FileRead</b></font>( Handle: THandle; <b>var</b> Buffer; Count: <b>DWord</b> ): <b>DWord</b>;</font>
<br>
Reads bytes from current position in file to buffer. Returns number of
read bytes.
</p>
<a name="file2str"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>File2Str</b></font>( Handle: THandle ): AnsiString;</font>
<br>
Reads file from current position to the end and returns result as ansi string.
</p>
<a name="file2wstr"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>File2WStr</b></font>( Handle: THandle ): WideString;</font>
<br>
Reads UNICODE file from current position to the end and returns result as
unicode string.
</p>
<a name="filewrite"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FileWrite</b></font>( Handle: THandle; <b>const</b> Buffer; Count: <b>DWord</b> ): <b>DWord</b>;</font>
<br>
Writes bytes from buffer to file from current position, extending its
size if needed.
</p>
<a name="fileeof"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FileEOF</b></font>( Handle: THandle ): <b>Boolean</b>;</font>
<br>
Returns True, if EOF is achieved during read operations or last byte is
overwritten or append made to extend file during last write operation.
</p>
<a name="filefullpath"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FileFullPath</b></font>( <b>const</b> FileName: KOLString ): KOLString;</font>
<br>
Returns full path name for given file. Validness of source FileName path
is not checked at all.
</p>
<a name="fileshortpath"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FileShortPath</b></font>( <b>const</b> FileName: KOLString ): KOLString;</font>
<br>
Returns short path to the file or directory.
</p>
<a name="fileiconsystemidx"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FileIconSystemIdx</b></font>( <b>const</b> Path: KOLString ): <b>Integer</b>;</font>
<br>
Returns index of the index of the system icon correspondent to the file or
directory in system icon image list.
</p>
<a name="fileiconsysidxoffline"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FileIconSysIdxOffline</b></font>( <b>const</b> Path: KOLString ): <b>Integer</b>;</font>
<br>
The same as <a href=#fileiconsystemidx>FileIconSystemIdx</a>, but an icon is calculated for the file
as it were offline (it is possible to get an icon for file even if
it is not existing, on base of its extension only).
</p>
<a name="diriconsysidxoffline"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DirIconSysIdxOffline</b></font>( <b>const</b> Path: KOLString ): <b>Integer</b>;</font>
<br>
The same as <a href=#fileiconsysidxoffline>FileIconSysIdxOffline</a>, but for a folder rather then for a file.
</p>
<a name="logfileoutput"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>LogFileOutput</b></font>( <b>const</b> filepath, str: KOLString );</font>
<br>
Debug function. Use it to append given string to the end of the given file.
</p>
<a name="str2file"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Str2File</b></font>( Filename: PKOLChar; Str: PAnsiChar ): <b>Boolean</b>;</font>
<br>
Save null-terminated string to file directly. If file does not exists, it is
created. If it exists, it is overriden. If operation failed, FALSE is returned.
</p>
<a name="wstr2file"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WStr2File</b></font>( Filename: PKOLChar; Str: PWideChar ): <b>Boolean</b>;</font>
<br>
Save null-terminated wide string to file directly. If file does not exists, it is
created. If it exists, it is overriden. If operation failed, FALSE is returned.
</p>
<a name="strsavetofile"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrSaveToFile</b></font>( <b>const</b> Filename: KOLString; <b>const</b> Str: AnsiString ): <b>Boolean</b>;</font>
<br>
Saves a string to a file without any changes. If file does not exists, it is
created. If it exists, it is overriden. If operation failed, FALSE is returned.
</p>
<a name="strloadfromfile"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>StrLoadFromFile</b></font>( <b>const</b> Filename: KOLString ): AnsiString;</font>
<br>
Reads entire file and returns its content as a string. If operation failed,
an empty strinng is returned.
<br>by Sergey Shishmintzev: it is possible to pass Filename = 'CON' to
read input from redirected console output.
</p>
<a name="wstrsavetofile"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WStrSaveToFile</b></font>( <b>const</b> Filename: KOLString; <b>const</b> Str: WideString ): <b>Boolean</b>;</font>
<br>
Saves a string to a file without any changes. If file does not exists, it is
created. If it exists, it is overriden. If operation failed, FALSE is returned.
</p>
<a name="wstrloadfromfile"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WStrLoadFromFile</b></font>( <b>const</b> Filename: KOLString ): WideString;</font>
<br>
Reads entire file and returns its content as a string. If operation failed,
an empty strinng is returned.
<br>by Sergey Shishmintzev: it is possible to pass Filename = 'CON' to
read input from redirected console output.
</p>
<a name="mem2file"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Mem2File</b></font>( Filename: PKOLChar; Mem: <b>Pointer</b>; Len: <b>Integer</b> ): <b>Integer</b>;</font>
<br>
Saves memory block to a file (if file exists it is overriden, created new if
not exists).
</p>
<a name="file2mem"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>File2Mem</b></font>( Filename: PKOLChar; Mem: <b>Pointer</b>; MaxLen: <b>Integer</b> ): <b>Integer</b>;</font>
<br>
Loads file content to memory.
</p>
<a name="filetime"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>FileTime</b></font>( <b>const</b> Path: KOLString; CreateTime, LastAccessTime, LastModifyTime: PFileTime );</font>
<br>
Returns file times without opening it.
</p>
<a name="getuniquefilename"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetUniqueFilename</b></font>( PathName: KOLString ): KOLString;</font>
<br>
If file given by PathName exists, modifies it to create unique
filename in target folder and returns it. Modification is performed
by incrementing last number in name (if name part of file does not
represent a number, such number is generated and concatenated to
it). E.g., if file aaa.aaa is already exist, the function checks
names aaa1.aaa, aaa2.aaa, ..., aaa10.aaa, etc. For name abc123.ext,
names abc124.ext, abc125.ext, etc. will be checked.
</p>
<a name="filetimecompare"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FileTimeCompare</b></font>( <b>const</b> FT1, FT2: TFileTime ): <b>Integer</b>;</font>
<br>
Compares time of file (createing, writing, accessing. Returns
-1, 0, 1 if correspondantly FT1&lt;FT2, FT1=FT2, FT1&gt;FT2.
</p>
<a name="directoryexists"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DirectoryExists</b></font>( <b>const</b> Name: KOLString ): <b>Boolean</b>;</font>
<br>
Returns True if given directory (folder) exists.
</p>
<a name="diskpresent"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DiskPresent</b></font>( <b>const</b> DrivePath: KOLString ): <b>Boolean</b>;</font>
<br>
Returns TRUE if the disk is present
</p>
<a name="wdirectoryexists"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WDirectoryExists</b></font>( <b>const</b> Name: WideString ): <b>Boolean</b>;</font>
<br>
</p>
<a name="checkdirectorycontent"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CheckDirectoryContent</b></font>( <b>const</b> Name: KOLString; SubDirsOnly: <b>Boolean</b>; <b>const</b> Mask: AnsiString ): <b>Boolean</b>;</font>
<br>
Returns TRUE if directory does not contain files (or directories only)
satisfying given mask.
</p>
<a name="directoryempty"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DirectoryEmpty</b></font>( <b>const</b> Name: KOLString ): <b>Boolean</b>;</font>
<br>
Returns True if given directory is not exists or empty.
</p>
<a name="directoryhassubdirs"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DirectoryHasSubdirs</b></font>( <b>const</b> Path: KOLString ): <b>Boolean</b>;</font>
<br>
Returns TRUE if given directory exists and has subdirectories.
</p>
<a name="getstartdir"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetStartDir</b></font>: KOLString;</font>
<br>
Returns path to directory where executable is located (regardless
of current directory).
</p>
<a name="exepath"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ExePath</b></font>: KOLString;</font>
<br>
Returns the path to the exe-file (in case of dll hook, this is exe-file
of the process in which context dll hook function is called).
</p>
<a name="modulepath"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ModulePath</b></font>: KOLString;</font>
<br>
Returns the path to the module (exe, dll) itself.
</p>
<a name="excludetrailingchar"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ExcludeTrailingChar</b></font>( <b>const</b> S: KOLString; C: KOLChar ): KOLString;</font>
<br>
If S is finished with character C, it is excluded.
</p>
<a name="includetrailingchar"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>IncludeTrailingChar</b></font>( <b>const</b> S: KOLString; C: KOLChar ): KOLString;</font>
<br>
If S is not finished with character C, it is added.
</p>
<a name="includetrailingpathdelimiter"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>IncludeTrailingPathDelimiter</b></font>( <b>const</b> S: KOLString ): KOLString;</font>
<br>
by Edward Aretino. Adds '\' to the end if it is not present.
</p>
<a name="excludetrailingpathdelimiter"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ExcludeTrailingPathDelimiter</b></font>( <b>const</b> S: KOLString ): KOLString;</font>
<br>
by Edward Aretino. Removes '\' at the end if it is present.
</p>
<a name="extractfiledrive"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ExtractFileDrive</b></font>( <b>const</b> Path: KOLString ): KOLString;</font>
<br>
Returns only drive part from exact path to a file or a directory.
For network paths, returns a computer name together with a following
name of shared directory (like '\\compname\shared\' ).
</p>
<a name="extractfilepath"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ExtractFilePath</b></font>( <b>const</b> Path: KOLString ): KOLString;</font>
<br>
Returns only path part from exact path to file.
</p>
<a name="wextractfilepath"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WExtractFilePath</b></font>( <b>const</b> Path: WideString ): WideString;</font>
<br>
Returns only path part from exact path to file.
</p>
<a name="isnetworkpath"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>IsNetworkPath</b></font>( <b>const</b> Path: KOLString ): <b>Boolean</b>;</font>
<br>
Returns TRUE, if Path is starting from '\\'.
</p>
<a name="extractfilename"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ExtractFileName</b></font>( <b>const</b> Path: KOLString ): KOLString;</font>
<br>
Extracts file name from exact path to file.
</p>
<a name="extractfilenamewoext"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ExtractFileNameWOext</b></font>( <b>const</b> Path: KOLString ): KOLString;</font>
<br>
Extracts file name from path to file or from filename.
</p>
<a name="extractfileext"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ExtractFileExt</b></font>( <b>const</b> Path: KOLString ): KOLString;</font>
<br>
Extracts extention from file name (returns it with dot '.' first)
</p>
<a name="replaceext"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ReplaceExt</b></font>( <b>const</b> Path, NewExt: KOLString ): KOLString;</font>
<br>
Returns Path to a file with extension replaced to a new extension.
Pass a new extension started with '.', e.g. '.txt'.
</p>
<a name="forcedirectories"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ForceDirectories</b></font>( Dir: KOLString ): <b>Boolean</b>;</font>
<br>
by Edward Aretino. Creates given directory if not present. All needed
subdirectories are created if necessary.
</p>
<a name="createdir"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CreateDir</b></font>( <b>const</b> Dir: KOLString ): <b>Boolean</b>;</font>
<br>
by Edward Aretino. Creates given directory.
</p>
<a name="changefileext"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ChangeFileExt</b></font>( FileName: KOLString; <b>const</b> Extension: KOLString ): KOLString;</font>
<br>
by Edward Aretino. Changes file extention.
</p>
<a name="replacefileext"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ReplaceFileExt</b></font>( <b>const</b> Path, NewExt: KOLString ): KOLString;</font>
<br>
Returns a path with extension replaced to a given one.
</p>
<a name="extractshortpathname"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ExtractShortPathName</b></font>( <b>const</b> Path: KOLString ): KOLString;</font>
<br>
</p>
<a name="filepathshortened"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FilePathShortened</b></font>( <b>const</b> Path: KOLString; MaxLen: <b>Integer</b> ): KOLString;</font>
<br>
Returns shortened file path to fit MaxLen characters.
</p>
<a name="filepathshortenpixels"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FilePathShortenPixels</b></font>( <b>const</b> Path: KOLString; DC: HDC; MaxPixels: <b>Integer</b> ): KOLString;</font>
<br>
Returns shortened file path to fit MaxPixels for a given DC. If you pass
Canvas.Handle of any control or bitmap object, ensure that font is valid
for it (or call <a href=tcanvas.htm#requiredstate>TCanvas.RequiredState</a>( FontValid ) method before. If DC passed
= 0, call is equivalent to call <a href=#filepathshortened>FilePathShortened</a>, and MaxPixels means in such
case maximum number of characters.
</p>
<a name="minimizename"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>MinimizeName</b></font>( <b>const</b> Path: KOLString; DC: HDC; MaxPixels: <b>Integer</b> ): KOLString;</font>
<br>
Exactly the same as MinimizeName in FileCtrl.pas (VCL).
</p>
<a name="getsystemdir"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetSystemDir</b></font>: KOLString;</font>
<br>
Returns path to windows system directory.
</p>
<a name="getwindowsdir"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetWindowsDir</b></font>: KOLString;</font>
<br>
Returns path to Windows directory.
</p>
<a name="getworkdir"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetWorkDir</b></font>: KOLString;</font>
<br>
Returns path to application's working directory.
</p>
<a name="gettempdir"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetTempDir</b></font>: KOLString;</font>
<br>
Returns path to default temp folder (directory to place temporary files).
</p>
<a name="createtempfile"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CreateTempFile</b></font>( <b>const</b> DirPath, Prefix: KOLString ): KOLString;</font>
<br>
Returns path to just created temporary file.
</p>
<a name="getfileliststr"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetFileListStr</b></font>( FPath, FMask: KOLString ): KOLString;</font>
<br>
List of files in string, separating each path from others with a character stored
in FileOpSeparator variables (#13 by default).
E.g.: 'c:\tmp\unit1.dcu'#13'c:\tmp\unit1.~pa' (for use with <a href=#deletefile2recycle>DeleteFile2Recycle</a>())
</p>
<a name="deletefiles"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DeleteFiles</b></font>( <b>const</b> DirPath: KOLString ): <b>Boolean</b>;</font>
<br>
Deletes files by file mask (given with wildcards '*' and '?').
</p>
<a name="dofileop"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DoFileOp</b></font>( <b>const</b> FromList, ToList: KOLString; FileOp: UINT; Flags: <b>Word</b>; Title: PKOLChar ): <b>Boolean</b>;</font>
<br>
By Unknown Mystic. FileOp can be: FO_MOVE, FO_COPY, FO_DELETE, FO_RENAME.
Flags can be a combination of values: FOF_MULTIDESTFILES, FOF_CONFIRMMOUSE,
FOF_SILENT, FOF_RENAMEONCOLLISION, FOF_NOCONFIRMATION, FOF_WANTMAPPINGHANDLE,
FOF_ALLOWUNDO, FOF_FILESONLY, FOF_SIMPLEPROGRESS, FOF_NOCONFIRMMKDIR,
FOF_NOERRORUI. Title used only with FOF_SIMPLEPROGRESS.
</p>
<a name="deletefile2recycle"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DeleteFile2Recycle</b></font>( <b>const</b> Filename: KOLString ): <b>Boolean</b>;</font>
<br>
Deletes file to recycle bin. This operation can be very slow, when
called for a single file. To delete group of files at once (fast),
pass a list of paths to files to be deleted, separating each path
from others with a character stored in FileOpSeparator variable (by default #13,
but in case when OLD_COMPAT symbol added - ';'). E.g.: 'unit1.dcu'#13'unit1.~pa'
<br>
FALSE is returned only in case when at least one file was not deleted
successfully.
<br>
Note, that files are deleted not to recycle bin, if wildcards are
used or not fully qualified paths to files.
</p>
<a name="copymovefiles"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CopyMoveFiles</b></font>( <b>const</b> FromList, ToList: KOLString; Move: <b>Boolean</b> ): <b>Boolean</b>;</font>
<br>
</p>
<a name="diskfreespace"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DiskFreeSpace</b></font>( <b>const</b> Path: KOLString ): <a href=#i64>I64</a>;</font>
<br>
Returns disk free space in bytes. Pass a path to root directory,
e.g. 'C:\'.
<hr>
<a name="Wrappers to registry API functions"></a><font color=#FF8040><h1>Wrappers to registry API functions</h1></font>

These functions can be used independently to simplify access to Windows
registry.
</p>
<a name="regkeyopenread"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyOpenRead</b></font>( Key: HKey; <b>const</b> SubKey: KOLString ): HKey;</font>
<br>
Opens registry key for read operations (including enumerating of subkeys).
Pass either handle of opened earlier key or one of constans
HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS
as a first parameter. If not successful, 0 is returned.
</p>
<a name="regkeyopenwrite"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyOpenWrite</b></font>( Key: HKey; <b>const</b> SubKey: KOLString ): HKey;</font>
<br>
Opens registry key for write operations (including adding new values or
subkeys), as well as for read operations too. See also <a href=#regkeyopenread>RegKeyOpenRead</a>.
</p>
<a name="regkeyopencreate"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyOpenCreate</b></font>( Key: HKey; <b>const</b> SubKey: KOLString ): HKey;</font>
<br>
Creates and opens key.
</p>
<a name="regkeygetstr"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyGetStr</b></font>( Key: HKey; <b>const</b> ValueName: KOLString ): KOLString;</font>
<br>
Reads key, which must have type REG_SZ (null-terminated string). If
not successful, empty string is returned. This function as well as all
other registry manipulation functions, does nothing, if Key passed is 0
(without producing any error).
</p>
<a name="regkeygetstrex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyGetStrEx</b></font>( Key: HKey; <b>const</b> ValueName: KOLString ): KOLString;</font>
<br>
Like <a href=#regkeygetstr>RegKeyGetStr</a>, but accepts REG_EXPAND_SZ type, expanding all
environment variables in resulting string.
<br>
Code provided by neuron, e-mailto:neuron@hollowtube.mine.nu
</p>
<a name="regkeygetdw"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyGetDw</b></font>( Key: HKey; <b>const</b> ValueName: KOLString ): <b>DWORD</b>;</font>
<br>
Reads key value, which must have type REG_DWORD. If ValueName passed
is '' (empty string), unnamed (default) value is reading. If not
successful, 0 is returned.
</p>
<a name="regkeysetstr"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeySetStr</b></font>( Key: HKey; <b>const</b> ValueName: KOLString; <b>const</b> Value: KOLString ): <b>Boolean</b>;</font>
<br>
Writes new key value as null-terminated string (type REG_SZ). If not
successful, returns False.
</p>
<a name="regkeysetstrex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeySetStrEx</b></font>( Key: HKey; <b>const</b> ValueName: KOLString; <b>const</b> Value: KOLString; expand: <b>Boolean</b> ): <b>Boolean</b>;</font>
<br>
Writes new key value as REG_SZ or REG_EXPAND_SZ. - by neuron, e-mailto:neuron@hollowtube.mine.nu
</p>
<a name="regkeysetdw"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeySetDw</b></font>( Key: HKey; <b>const</b> ValueName: KOLString; Value: <b>DWORD</b> ): <b>Boolean</b>;</font>
<br>
Writes new key value as dword (with type REG_DWORD). Returns False,
if not successful.
</p>
<a name="regkeyclose"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>RegKeyClose</b></font>( Key: HKey );</font>
<br>
Closes key, opened using <a href=#regkeyopenread>RegKeyOpenRead</a> or <a href=#regkeyopenwrite>RegKeyOpenWrite</a>. (But does
nothing, if Key passed is 0).
</p>
<a name="regkeydelete"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyDelete</b></font>( Key: HKey; <b>const</b> SubKey: KOLString ): <b>Boolean</b>;</font>
<br>
Deletes key. Does nothing if key passed is 0 (returns FALSE).
</p>
<a name="regkeydeletevalue"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyDeleteValue</b></font>( Key: HKey; <b>const</b> SubKey: KOLString ): <b>Boolean</b>;</font>
<br>
Deletes value. - by neuron, e-mailto:neuron@hollowtube.mine.nu
</p>
<a name="regkeyexists"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyExists</b></font>( Key: HKey; <b>const</b> SubKey: AnsiString ): <b>Boolean</b>;</font>
<br>
Returns TRUE, if given subkey exists under given Key.
</p>
<a name="regkeyvalexists"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyValExists</b></font>( Key: HKey; <b>const</b> ValueName: KOLString ): <b>Boolean</b>;</font>
<br>
Returns TRUE, if given value exists under the Key.
</p>
<a name="regkeyvaluesize"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyValueSize</b></font>( Key: HKey; <b>const</b> ValueName: KOLString ): <b>Integer</b>;</font>
<br>
Returns a size of value. This is a size of buffer needed to store
registry key value. For string value, size returned is equal to a
length of string plus 1 for terminated null character.
</p>
<a name="regkeygetbinary"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyGetBinary</b></font>( Key: HKey; <b>const</b> ValueName: KOLString; <b>var</b> Buffer; Count: <b>Integer</b> ): <b>Integer</b>;</font>
<br>
Reads binary data from a registry, writing it to the Buffer.
It is supposed that size of Buffer provided is at least Count bytes.
Returned value is actul count of bytes read from the registry and written
to the Buffer.
<br>
This function can be used to get data of any type from the registry, not
only REG_BINARY.
</p>
<a name="regkeysetbinary"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeySetBinary</b></font>( Key: HKey; <b>const</b> ValueName: KOLString; <b>const</b> Buffer; Count: <b>Integer</b> ): <b>Boolean</b>;</font>
<br>
Stores binary data in the registry.
</p>
<a name="regkeygetdatetime"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyGetDateTime</b></font>( Key: HKey; <b>const</b> ValueName: KOLString ): TDateTime;</font>
<br>
Returns datetime variable stored in registry in binary format.
</p>
<a name="regkeysetdatetime"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeySetDateTime</b></font>( Key: HKey; <b>const</b> ValueName: KOLString; DateTime: TDateTime ): <b>Boolean</b>;</font>
<br>
Stores DateTime variable in the registry.
</p>
<a name="regkeygetsubkeys"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyGetSubKeys</b></font>( <b>const</b> Key: HKEY; List: PKOLStrList ): <b>Boolean</b>;</font>
<br>
The function enumerates subkeys of the specified open registry key.
True is returned, if successful.
</p>
<a name="regkeygetvaluenames"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyGetValueNames</b></font>( <b>const</b> Key: HKEY; List: PKOLStrList ): <b>Boolean</b>;</font>
<br>
The function enumerates value names of the specified open registry key.
True is returned, if successful.
</p>
<a name="regkeygetvaluetyp"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>RegKeyGetValueTyp</b></font>( <b>const</b> Key: HKEY; <b>const</b> ValueName: KOLString ): <b>DWORD</b>;</font>
<br>
The function receives the type of data stored in the specified value.
<br>
If the function fails, the return value is the Key value.
<br>
If the function succeeds, the return value return will be one of the following:
<br>
REG_BINARY , REG_DWORD, REG_DWORD_LITTLE_ENDIAN,
REG_DWORD_BIG_ENDIAN, REG_EXPAND_SZ, REG_LINK , REG_MULTI_SZ,
REG_NONE, REG_RESOURCE_LIST, REG_SZ
<hr>
<a name="Data sorting (quicksort implementation)"></a><font color=#FF8040><h1>Data sorting (quicksort implementation)</h1></font>

This part contains implementation of 'quick sort' algorithm,
based on following code:
<pre>
 TQSort by Mike Junkin 10/19/95.
 DoQSort routine adapted from Peter Szymiczek's QSort procedure which
 was presented in issue#8 of The Unofficial Delphi Newsletter.
 TQSort changed by Vladimir Kladov (Mr.Bonanzas) to allow 32-bit
 sorting (of big arrays with more than 64K elements).
</pre>
Finally, this sort procedure is adapted to XCL (and then to KOL)
requirements (no references to SysUtils, Classes etc. TQSort object
is transferred to a single procedure call and DoQSort method is
renamed to <a href=#sortdata>SortData</a> - which is a regular procedure now).
</p>
<a name="tcompareevent"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TCompareEvent</b></font> = <b>function</b>( <b>const</b> Data: <b>Pointer</b>; <b>const</b> e1, e2: <b>Dword</b> ): <b>Integer</b>;</font>
<br>
Event type to define comparison function between two elements of an array.
This event handler must return -1 or +1 (correspondently for cases e1&lt;e2
and e2&gt;e2). Items are enumerated from 0 to uNElem.
</p>
<a name="tswapevent"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TSwapEvent</b></font> = <b>procedure</b>( <b>const</b> Data: <b>Pointer</b>; <b>const</b> e1, e2: <b>Dword</b> );</font>
<br>
Event type to define swap procedure which is swapping two elements of an
array.
</p>
<a name="sortdata"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>SortData</b></font>( <b>const</b> Data: <b>Pointer</b>; <b>const</b> uNElem: <b>Dword</b>; <b>const</b> CompareFun: <a href=#tcompareevent>TCompareEvent</a>; <b>const</b> SwapProc: <a href=#tswapevent>TSwapEvent</a> );</font>
<br>
Call it to sort any array of data of any kind, passing total
number of items in an array and two defined (regular) function
and procedure to perform custom compare and swap operations.
First procedure parameter is to pass it to callback function
CompareFun and procedure SwapProc. Items are enumerated from
0 to uNElem-1.
</p>
<a name="swaplistitems"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>SwapListItems</b></font>( <b>const</b> L: <b>Pointer</b>; <b>const</b> e1, e2: <b>DWORD</b> );</font>
<br>
Use this function as the last parameter for <a href=#sortdata>SortData</a> call when a <a href=#plist>PList</a>
object is sorting. SwapListItems just exchanges two items of the list.
</p>
<a name="sortintegerarray"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>SortIntegerArray</b></font>( <b>var</b> A: <b>array</b> <b>of</b> <b>Integer</b> );</font>
<br>
procedure to sort array of integers.
</p>
<a name="sortdwordarray"></a>
<p>
<font face="Courier" color="#800080"><b>procedure</b> <font color="#808000"><b>SortDwordArray</b></font>( <b>var</b> A: <b>array</b> <b>of</b> <b>DWORD</b> );</font>
<br>
Procedure to sort array of unsigned 32-bit integers.
<hr>
</p>
<a name="tsortdirrules"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TSortDirRules</b></font> =( sdrNone, sdrFoldersFirst, sdrCaseSensitive, sdrByName, sdrByExt, sdrBySize, sdrBySizeDescending, sdrByDateCreate, sdrByDateChanged, sdrByDateAccessed );</font>
<br>
List of rules (options) to sort directories. Rules are passed to Sort
method in an array, and first placed rules are applied first.
</p>
<a name="newdirlist"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewDirList</b></font>( <b>const</b> DirPath, Filter: KOLString; Attr: <b>DWORD</b> ): PDirList;</font>
<br>
Creates directory list object using easy one-string filter. If Attr = FILE_ATTRIBUTE_NORMAL,
only files are scanned without directories. If Attr = 0, both files and
directories are listed.
</p>
<a name="newdirlistex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewDirListEx</b></font>( <b>const</b> DirPath, Filters: KOLString; Attr: <b>DWORD</b> ): PDirList;</font>
<br>
Creates directory list object using several filters, separated by ';'.
Filters starting from '^' consider to be anti-filters, i.e. files,
satisfying to those masks, are skept during scanning.
</p>
<a name="defsortdirrules"></a>
<p>
<font face="Courier" color="#800080"><b>var</b> <font color="#808000"><b>DefSortDirRules</b></font>: array[ 0 . . 3 ] <b>of</b> <a href=#tsortdirrules>TSortDirRules</a> =( sdrFoldersFirst, sdrByName, sdrBySize, sdrByDateCreate );</font>
<br>
Default rules to sort directory entries.
</p>
<a name="directorysize"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DirectorySize</b></font>( <b>const</b> Path: KOLString ): <a href=#i64>I64</a>;</font>
<br>
Returns directory size in bytes as large 64 bit integer.
</p>
<a name="topensaveoptions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOpenSaveOptions</b></font> = <b>set</b> <b>of</b> TOpenSaveOption;</font>
<br>
Options available for <a href=#topensavedialog>TOpenSaveDialog</a>.
</p>
<a name="newopensavedialog"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewOpenSaveDialog</b></font>( <b>const</b> Title, StrtDir: KOLString; Options: <a href=#topensaveoptions>TOpenSaveOptions</a> ): POpenSaveDialog;</font>
<br>
Creates object, which can be used (several times) to open file(s)
selecting dialog.
</p>
<a name="topendiroption"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOpenDirOption</b></font> =( odBrowseForComputer, odBrowseForPrinter, odDontGoBelowDomain, odOnlyFileSystemAncestors, odOnlySystemDirs, odStatusText, odBrowseIncludeFiles, odEditBox, odNewDialogStyle );</font>
<br>
Flags available for <a href=#topendirdialog>TOpenDirDialog</a> object.
</p>
<a name="topendiroptions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOpenDirOptions</b></font> = <b>set</b> <b>of</b> <a href=#topendiroption>TOpenDirOption</a>;</font>
<br>
Set of all flags used to control ZOpenDirDialog class.
</p>
<a name="tonodselchange"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnODSelChange</b></font> = <b>procedure</b>( Sender: POpenDirDialog; NewSelDir: PKOL_Char; <b>var</b> EnableOK: <b>Integer</b>; <b>var</b> StatusText: KOL_String ) <b>of</b> <b>object</b>;</font>
<br>
Event type to be called when user select another directory in OpenDirDialog.
Set EnableOK to -1 to disable OK button, or to +1 to enable it.
It is also possible to set new StatusText string.
</p>
<a name="newopendirdialog"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewOpenDirDialog</b></font>( <b>const</b> Title: KOLString; Options: <a href=#topendiroptions>TOpenDirOptions</a> ): POpenDirDialog;</font>
<br>
Creates object, which can be used (several times) to open directory
selecting dialog (using SHBrowseForFolder API call).
</p>
<a name="newcolordialog"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewColorDialog</b></font>( FullOpen: TColorCustomOption ): PColorDialog;</font>
<br>
Creates color choosing dialog object.
</p>
<a name="tinifilemode"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TIniFileMode</b></font> =( ifmRead, ifmWrite );</font>
<br>
ifmRead is default mode (means &quot;read&quot; data from ini-file.
Set mode to ifmWrite to write data to ini-file, correspondent to
<a href=#tinifile>TIniFile</a>.
</p>
<a name="openinifile"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>OpenIniFile</b></font>( <b>const</b> FileName: KOLString ): PIniFile;</font>
<br>
Opens ini file, creating <a href=#tinifile>TIniFile</a> object instance to work with it.
</p>
<a name="tonmenuitem"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TOnMenuItem</b></font> = <b>procedure</b>( Sender: PMenu; Item: <b>Integer</b> ) <b>of</b> <b>object</b>;</font>
<br>
Event type to define OnMenuItem event.
</p>
<a name="tmenuaccelerator"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TMenuAccelerator</b></font> = <b>packed</b> <b>Record</b></font>
<br>
Menu accelerator record. Use <a href=#makeaccelerator>MakeAccelerator</a> function to combine desired
attributes into a record, describing the accelerator.
<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">fVirt: <b>Byte</b>;</font>
    </td>
    <td valign="top">
or-combination of FSHIFT, FCONTROL, FALT, FVIRTKEY, FNOINVERT
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">Key: <b>Word</b>;</font>
    </td>
    <td valign="top">
character or virtual key code (FVIRTKEY flag is present above)
    </td>
  </tr>
  <tr>
    <td width="32">&nbsp;</td>
    <td valign="top">
<font face="Courier" color="#800080">NotUsed: <b>Byte</b>;</font>
    </td>
    <td valign="top">
not used
    </td>
  </tr>
</table>
<font face="Courier" color="#800080"><b>end</b>;</font>
</p>
<a name="tmenuoption"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TMenuOption</b></font> =( moDefault, moDisabled, moChecked, moCheckMark, moRadioMark, moSeparator, moBitmap, moSubMenu, moBreak, moBarBreak );</font>
<br>
Options to add menu items dynamically.
</p>
<a name="tmenuoptions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TMenuOptions</b></font> = <b>set</b> <b>of</b> <a href=#tmenuoption>TMenuOption</a>;</font>
<br>
Set of options for menu item to use it in TMenu.AddItem method.
</p>
<a name="tmenubreak"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TMenuBreak</b></font> =( mbrNone, mbrBreak, mbrBarBreak );</font>
<br>
Possible menu item break types.
</p>
<a name="menustructsize"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>MenuStructSize</b></font>: <b>Integer</b>;</font>
<br>
Returns 44 under Windows95, and 48 (=sizeof(TMenuItemInfo) under all other
Windows versions.
</p>
<a name="newmenu"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewMenu</b></font>( AParent: <a href=#pcontrol>PControl</a>; MaxCmdReserve: <b>DWORD</b>; <b>const</b> Template: <b>array</b> <b>of</b> PKOLChar; aOnMenuItem: <a href=#tonmenuitem>TOnMenuItem</a> ): PMenu;</font>
<br>
Menu constructor. First created menu becomes main menu of form (if AParent
is a form). All other menus becomes popup (can be activated using Popup
method). To provide dynamic replacing of main menu, create all popup
menus as children of any other control, not form itself.
When Menu is created, pass FirstCmd integer value to set it
as ID of first menu item (all other ID's obtained by incrementing this value),
and Template, which is an array of PChar (usually array of string constants),
containing list of menu item identifiers and/or formatting characters.
<br>&nbsp;&nbsp;&nbsp;
FirstCmd value is assigned to first menu item created as its ID,
all follow menu items are assigned to ID's obtained from FirstCmd incrementing
it by 1. It is desirable to provide not intersected ranges of ID's for
defferent menus in the applet.
<br>&nbsp;&nbsp;&nbsp;
Following formatting characters can be used in menu template strings:
<br><b>&amp; (in identifier)</b>
- to underline next character and use it as a shortcut character
when possible;
<br><b>+ (in front of identifier)</b>
- to make item checked. If also
<b>!</b> is used before <b>
&amp;
</b> than radioitem is defined;
<br><b>- (in front of identifier)</b>
- item not checked;
<br><b>- (separate)</b>
- separator (between two items);
<br><b>( (separate)</b>
- start of submenu;
<br><b>) (separate)</b>
- end of submenu;
<br>&nbsp;&nbsp;&nbsp;
To get access to menu items, use constants 0, 1, etc. It is a good idea
to create special enumerated type to index correspondent menu items
using Ord( ) operator. Note in that case, that it is necessary only to
define constants correspondent to identifiers (positions, correspondent
to separators or submenu brackets are not identified by numbers).
<br>&nbsp;&nbsp;&nbsp;
</p>
<a name="newmenuex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>NewMenuEx</b></font>( AParent: <a href=#pcontrol>PControl</a>; FirstCmd: <b>Integer</b>; <b>const</b> Template: <b>array</b> <b>of</b> PKOLChar; aOnMenuItems: <b>array</b> <b>of</b> <a href=#tonmenuitem>TOnMenuItem</a> ): PMenu;</font>
<br>
Creates menu, assigning its own event handler for every (enough) menu item.
</p>
<a name="makeaccelerator"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>MakeAccelerator</b></font>( fVirt: <b>Byte</b>; Key: <b>Word</b> ): <a href=#tmenuaccelerator>TMenuAccelerator</a>;</font>
<br>
Creates accelerator item to assign it to TMenu.ItemAccelerator[ ] property
easy.
</p>
<a name="getacceleratortext"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetAcceleratorText</b></font>( <b>const</b> Accelerator: <a href=#tmenuaccelerator>TMenuAccelerator</a> ): KOLString;</font>
<br>
Returns text representation of accelerator.
<hr>
<a name="System functions and working with windows"></a><font color=#FF8040><h1>System functions and working with windows</h1></font>

</p>
<a name="twindowchildkind"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TWindowChildKind</b></font> =( wcActive, wcFocus, wcCapture, wcMenuOwner, wcMoveSize, wcCaret );</font>
<br>
Type of window child kind. Used in function <a href=#getwindowchild>GetWindowChild</a>.
</p>
<a name="getwindowchild"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetWindowChild</b></font>( Wnd: HWnd; Kind: <a href=#twindowchildkind>TWindowChildKind</a> ): HWnd;</font>
<br>
Returns child of given top-level window, having given characteristics.
For example, it is possible to get know for foreground window,
which of its child window has focus. This function does not work in old
Windows 95 (returns Wnd in that case). But for Windows 98, Windows NT/2000
this function works fine. To obtain focused child of the window,
use GetFocusedWindow, which is independant from Windows version.
</p>
<a name="getfocusedchild"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetFocusedChild</b></font>( Wnd: HWnd ): HWnd;</font>
<br>
Returns focused child of given window (which should be foreground
and active, certainly). 0 is returned either if Wnd is not active
or Wnd has no focused child window.
</p>
<a name="stroke2window"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Stroke2Window</b></font>( Wnd: HWnd; <b>const</b> S: AnsiString ): <b>Boolean</b>;</font>
<br>
Posts characters from string S to those child window of Wnd, which
has focus now (top-level window Wnd must be foreground, and have
focused edit-aware control to receive the stroke).
<br>
This function allows only to post typeable characters (including
such special symbols as #13 (Enter), #9 (Tab), #8 (BackSpace), etc.
<br>
See also function <a href=#stroke2windowex>Stroke2WindowEx</a>, which allows to post any key down
and up events, simulating keyboard for given (automated) application.
</p>
<a name="stroke2windowex"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>Stroke2WindowEx</b></font>( Wnd: HWnd; <b>const</b> S: AnsiString; Wait: <b>Boolean</b> ): <b>Boolean</b>;</font>
<br>
In addition to function <a href=#stroke2window>Stroke2Window</a>, this one can send special keys
to given window, including functional keys and navigation keys. To
post special key to target window, place a combination of names of
such key together with keys, which should be passed simultaneously,
between square or figure brackets. For example, [Ctrl F1], [Alt Shift Home],
[Ctrl E]. For letters and usual characters, it is not necessary to
simulate pressing it with determining all Shift combinations and it is
sufficient to pass characters as is. (E.g., not '[Shift 1]', but '!').
</p>
<a name="findwindowbythreadid"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>FindWindowByThreadID</b></font>( ThreadID: <b>DWORD</b> ): HWnd;</font>
<br>
Searches for window, belonging to a given thread.
</p>
<a name="desktoppixelformat"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>DesktopPixelFormat</b></font>: <a href=#tpixelformat>TPixelFormat</a>;</font>
<br>
Returns the pixel format correspondent to current desktop color resolution.
Use this function to decide which format to use for converting bitmap,
planned to draw transparently using <a href=tbitmap.htm#drawtransparent>TBitmap.DrawTransparent</a> or
<a href=tbitmap.htm#stretchdrawtransparent>TBitmap.StretchDrawTransparent</a> methods.
</p>
<a name="getdesktoprect"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetDesktopRect</b></font>: TRect;</font>
<br>
Returns rectangle of screen, free of taskbar and other
similar app-bars, which reduces size of available desktop
when created.
</p>
<a name="getworkarea"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>GetWorkArea</b></font>: TRect;</font>
<br>
The same as <a href=#getdesktoprect>GetDesktopRect</a>, but obtained calling SystemParametersInfo.
</p>
<a name="executewait"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ExecuteWait</b></font>( <b>const</b> AppPath, CmdLine, DfltDirectory: KOLString; Show: <b>DWORD</b>; TimeOut: <b>DWORD</b>; ProcID: PDWORD ): <b>Boolean</b>;</font>
<br>
Allows to execute an application and wait when it is finished. Pass
INFINITE constant as TimeOut, if You sure that application is finished
anyway. If another value passed as a TimeOut (in milliseconds), and
application was not finished for that time, ExecuteWait is returning
FALSE, and if ProcID is not nil, than ProcID^ contains started process
handle (it can be used to wait it more, or to terminate it using
TerminateProcess API function).
<br>
Launching application can be console or GUI - it does not matter.
Pass SW_SHOW, SW_HIDE or other SW_XXX constant as Show parameter
as appropriate.
<br>
True is returned only in case when application specified was launched
successfully and finished for TimeOut specified. Otherwise, check
ProcID^ variable: if it is 0, process could not be launched (and it
is possible to get information about error using GetLastError API
function in a such case). You can freely pass nil in place of ProcID
parameter, but this is acually correct only when TimeOut is INFINITE.
</p>
<a name="executeioredirect"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ExecuteIORedirect</b></font>( <b>const</b> AppPath, CmdLine, DfltDirectory: KOLString; Show: <b>DWORD</b>; ProcID: PDWORD; InPipe, OutPipeWr, OutPipeRd: PHandle ): <b>Boolean</b>;</font>
<br>
Executes an application with its console input and output redirection.
Terminating of the application is not waiting, but if ProcID pointer
is defined, it receives process Id launched, so it is possible to
call WaitForSingleObject for it. InPipe is a pointer to THandle variable
which receives a handle to input pipe of the console redirected. The same
is for OutPipeWr and OutPipeRd, but for output of the console redirected.
Before reading from OutPipeRd^, first close OutPipeWr^. If you run
simple console application, for which you want to read results after its
termination, you can use <a href=#executeconsoleappioredirect>ExecuteConsoleAppIORedirect</a> instead.
<br>&nbsp;&nbsp;&nbsp;
Notes: if your application is not console and it does not create console
using AllocConsole, this function will fail to redirect input-output.
</p>
<a name="executeconsoleappioredirect"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ExecuteConsoleAppIORedirect</b></font>( <b>const</b> AppPath, CmdLine, DfltDirectory: AnsiString; Show: <b>DWORD</b>; <b>const</b> InStr: AnsiString; <b>var</b> OutStr: AnsiString; WaitTimeout: <b>DWORD</b> ): <b>Boolean</b>;</font>
<br>
Executes an application, redirecting its console input and output.
After redirecting input and output and launching the application,
content of InStr is written to input stream of the application, then
the application is waiting for its termination (WaitTimeout milliseconds
or INFINITE, as passed) and console output of the application is read to
OutStr. TRUE is returned only in case, when all these tasks are
completed successfully.
<br>&nbsp;&nbsp;&nbsp;
Notes: if your application is not console and it does not create console
using AllocConsole, this function will fail to redirect input-output.
</p>
<a name="windowsshutdown"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WindowsShutdown</b></font>( <b>const</b> Machine: KOLString; Force, Reboot: <b>Boolean</b> ): <b>Boolean</b>;</font>
<br>
Shut down of Windows NT. Pass Machine = '' to shutdown this PC.
Pass Reboot = True to reboot immediatelly after shut down.
</p>
<a name="windowslogoff"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WindowsLogoff</b></font>( Force: <b>Boolean</b> ): <b>Boolean</b>;</font>
<br>
Logoff of Windows.
</p>
<a name="twindowsversion"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TWindowsVersion</b></font> =( wv31, wv95, wv98, wvME, wvNT, wvY2K, wvXP, wvServer2003, wvVista, wvSeven );</font>
<br>
Windows versions constants.
</p>
<a name="twindowsversions"></a>
<p>
<font face="Courier" color="#800080"><b>type</b> <font color="#808000"><b>TWindowsVersions</b></font> = <b>Set</b> <b>of</b> <a href=#twindowsversion>TWindowsVersion</a>;</font>
<br>
Set of Windows version (e.g. to define a range of versions supported by the
application).
</p>
<a name="winver"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>WinVer</b></font>: <a href=#twindowsversion>TWindowsVersion</a>;</font>
<br>
Returns Windows version.
</p>
<a name="iswinver"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>IsWinVer</b></font>( Ver: <a href=#twindowsversions>TWindowsVersions</a> ): <b>Boolean</b>;</font>
<br>
Returns True if Windows version is in given range of values.
</p>
<a name="paramstr"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ParamStr</b></font>( Idx: <b>Integer</b> ): KOLString;</font>
<br>
Returns command-line parameter by index. This function supersides
standard ParamStr function.
</p>
<a name="paramcount"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>ParamCount</b></font>: <b>Integer</b>;</font>
<br>
Returns number of parameters in command line.
<hr>
</p>
<a name="crackstack_mapinresource"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CrackStack_MapInResource</b></font>( <b>const</b> MapName: KOLString; Max_length: <b>Integer</b>; HandleSuspiciousAddresses: <b>Boolean</b> ): KOLString;</font>
<br>
Allows to list all procedures and functions called before current cracking
stack frames. This version loads map-file from the resource.
Important note: you must provide latest map file created at the last
application build in the resource! See also <a href=#crackstack_mapinfile>CrackStack_MapInFile</a> below.
</p>
<a name="crackstack_mapinfile"></a>
<p>
<font face="Courier" color="#800080"><b>function</b> <font color="#808000"><b>CrackStack_MapInFile</b></font>( <b>const</b> MapFileName: KOLString; Max_length: <b>Integer</b>; HandleSuspiciousAddresses: <b>Boolean</b> ): KOLString;</font>
<br>
Allows to list all procedures and functions called before current cracking
stack frames. This version loads map-file from the file.
Important note: you must have the latest map file created at the last
application build on a path specified! For example, use path <a href=#getstartdir>GetStartDir</a> +
appname_wo_extention + '.map' and do not forget to set flag Map file -
Detailed in Project Options &brvbar; Linker. Use flag HandleSuspiciousAddresses
to show all suspicious addresses found in stack (this may help to find
errors not shown even by Delphi debugger since stack frames in some cases give
no enough data).
</p>
<a name="_tobj"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=_tobj.htm><b>_TObj</b></a> = <b>object</b></font>
<br>
auxiliary object type. See <a href=#tobj>TObj</a>.
</p>
<a name="tobj"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=tobj.htm><b>TObj</b></a> = <b>object</b>( <a href=#_tobj>_TObj</a> )</font>
<br>
Prototype for all objects of KOL. All its methods are important to
implement objects in a manner similar to Delphi TObject class.
</p>
<a name="tlist"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=tlist.htm><b>TList</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
Simple list of pointers. It is used in KOL instead of standard VCL
<a href=tlist.htm>TList</a> to store any kind data (or pointers to these ones). Can be created
calling function <a href=#newlist>NewList</a>.
</p>
<a name="tstrlist"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=tstrlist.htm><b>TStrList</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
Easy string list implementation (non-visual, just to store
string data). It is well improved and has very high performance
allowing to work fast with huge text files (more then megabyte
of text data).
Please note that #0 charaster if stored in string lines, will cut it
preventing reading the rest of a line. Be careful, if your data
contain such characters.
</p>
<a name="tstrlistex"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=tstrlistex.htm><b>TStrListEx</b></a> = <b>object</b>( <a href=#tstrlist>TStrList</a> )</font>
<br>
Extended string list object. Has additional capability to associate
numbers or objects with string list items.
</p>
<a name="twstrlist"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=twstrlist.htm><b>TWStrList</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
String list to store Unicode (null-terminated) strings.
</p>
<a name="twstrlistex"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=twstrlistex.htm><b>TWStrListEx</b></a> = <b>object</b>( <a href=#twstrlist>TWStrList</a> )</font>
<br>
Extended Unicode string list (with <a href=twstrlistex.htm#objects>Objects</a>).
</p>
<a name="tgraphictool"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=tgraphictool.htm><b>TGraphicTool</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
Incapsulates all GDI objects: Pen, Brush and Font.
</p>
<a name="tcanvas"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=tcanvas.htm><b>TCanvas</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
Very similar to VCL's <a href=tcanvas.htm>TCanvas</a> object. But with some changes, specific
for KOL: there is no necessary to use canvases in all applications.
And graphic tools objects are not created with canvas, but only
if really accessed in program. (Actually, even if paint box used,
only programmer decides, if to implement painting using Canvas or
to call low level API drawing functions working directly with DC).
Therefore <a href=tcanvas.htm>TCanvas</a> has some powerful extensions: rotated text support,
geometric pen support - just by changing correspondent properties
of certain graphic tool objects (Font.FontOrientation, Pen.GeometricPen).
See also additional <a href=tcanvas.htm#font>Font</a> properties (Font.FontWeight, Font.FontQuality,
etc.
</p>
<a name="timagelist"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=timagelist.htm><b>TImageList</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
ImageList incapsulation.
</p>
<a name="tbitmap"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=tbitmap.htm><b>TBitmap</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
Bitmap incapsulation object.
</p>
<a name="ticon"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=ticon.htm><b>TIcon</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
Object type to incapsulate icon or cursor image.
</p>
<a name="tcontrol"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=tcontrol.htm><b>TControl</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
<a href=tcontrol.htm>TControl</a> is the basic visual object of KOL. And now, all visual
objects have the same type <a href=#pcontrol>PControl</a>, differing only in &quot;constructor&quot;,
which during creating of object adjusts it so it can play role of
desired control. Idea of incapsulating of all visual objects having
the most common set of properties, is belonging to Vladimir Kladov,
(C) 2000.
<br>&nbsp;&nbsp;&nbsp;<b> Since all visual objects are represented
in KOL by this single object type, not all methods, properties and
events defined in <a href=tcontrol.htm>TControl</a>, are applicable to different visual objects.
See also notes about certain control kinds, located together with its
<a href="kol_pas.htm#visual_objects_constructors">
constructing functions definitions</a></b>.
</p>
<a name="ttimer"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=ttimer.htm><b>TTimer</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
Easy timer incapsulation object. It uses separate topmost window,
common for all timers in the application, to handle WM_TIMER message.
This allows using timers in non-windowed application (but anyway it
should contain message handling loop for a thread).
<br>
Note: in UNIX, there are no special windows created, certainly.
</p>
<a name="tmmtimer"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=tmmtimer.htm><b>TMMTimer</b></a> = <b>object</b>( <a href=#ttimer>TTimer</a> )</font>
<br>
Multimedia timer incapsulation object. Does not require <a href=#applet>Applet</a> or special
window to handle it. System creates a thread for each high resolution
timer, so using many such objects can degrade total PC performance.
</p>
<a name="ttrayicon"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=ttrayicon.htm><b>TTrayIcon</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
Object to place (and change) a single icon onto taskbar tray.
</p>
<a name="tdirlist"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=tdirlist.htm><b>TDirList</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
Allows easy directory scanning. This is not visual object, but
storage to simplify working with directory content.
</p>
<a name="topensavedialog"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=topensavedialog.htm><b>TOpenSaveDialog</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
Object to show standard Open/Save dialog. Initially provided
for XCL by Carlo Kok.
</p>
<a name="topendirdialog"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=topendirdialog.htm><b>TOpenDirDialog</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
Dialog for open directories, uses SHBrowseForFolder.
</p>
<a name="tcolordialog"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=tcolordialog.htm><b>TColorDialog</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
<a href=tcolordialog.htm#color>Color</a> choosing dialog.
</p>
<a name="tinifile"></a>
<p>
<font face="Courier" color="#808000"><b>type</b> <a href=tinifile.htm><b>TIniFile</b></a> = <b>object</b>( <a href=#tobj>TObj</a> )</font>
<br>
Ini file incapsulation. The main feature is what the same block of
read-write operations could be defined (difference must be only in
<a href=tinifile.htm#mode>Mode</a> value).
&nbsp;&nbsp;&nbsp;<a href="Inifilesample.htm"><font face="Webdings" size=7>&#181;</font></a>&nbsp;&nbsp;&nbsp;
</p>
<hr>
<p align="center">[&nbsp;<a href=index.htm>Index</a>&nbsp;]</p>
<p align="center"><font face="Comic Sans MS"><small>This help is generated 14-Jun-2010 by KOL Help generator, (C) 2000-2001 by Vladimir Kladov<br>Modified (C) 2003 by Alexander Bartov</small></font></p>
</body>
</html>
